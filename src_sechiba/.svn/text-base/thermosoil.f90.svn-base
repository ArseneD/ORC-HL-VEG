! =================================================================================================================================
! MODULE       : thermosoil
!
! CONTACT      : orchidee-help _at_ ipsl.jussieu.fr
!
! LICENCE      : IPSL (2006)
! This software is governed by the CeCILL licence see ORCHIDEE/ORCHIDEE_CeCILL.LIC
!
!>\BRIEF        Calculates the soil temperatures by solving the heat
!! diffusion equation within the soil
!!
!!\n DESCRIPTION : General important informations about the numerical scheme and
!!                 the soil vertical discretization:\n
!!               - the soil is divided into "ngrnd" (=7 by default) layers, reaching to as
!!                 deep as 5.5m down within the soil, with thiscknesses
!!                 following a geometric series of ration 2.\n
!!               - "jg" is usually used as the index going from 1 to ngrnd to describe the
!!                  layers, from top (jg=1) to bottom (jg=ngrnd)\n
!!               - the thermal numerical scheme is implicit finite differences.\n
!!                 -- When it is resolved in thermosoil_profile at the present timestep t, the
!!                 dependancy from the previous timestep (t-1) is hidden in the
!!                 integration coefficients cgrnd and dgrnd, which are therefore
!!                 calculated at the very end of thermosoil_main (call to
!!                 thermosoil_coef) for use in the next timestep.\n
!!                 -- At timestep t, the system becomes :\n 
!!
!!                              T(k+1)=cgrnd(k)+dgrnd(k)*T(k) \n
!!                                      -- EQ1 -- \n
!!
!!                 (the bottom boundary condition has been used to obtained this equation).\n
!!                 To solve it, the uppermost soil temperature T(1) is required.
!!                 It is obtained from the surface temperature Ts, which is
!!                 considered a linear extrapolation of T(1) and T(2)\n
!!
!!                           Ts=(1-lambda)*T(1) -lambda*T(2) \n 
!!                                      -- EQ2--\n
!!
!!                 -- caveat 1 : Ts is called 'temp_soil_new' in this routine,
!!                 don' t act.\n
!!                 -- caveat 2 : actually, the surface temperature at time t Ts
!!                 depends on the soil temperature at time t through the
!!                 ground heat flux. This is again implicitly solved, with Ts(t)
!!                 expressed as :\n
!!
!!                 soilcap*(Ts(t)-Ts(t-1))/dt=soilflux+otherfluxes(Ts(t))\n 
!!                                      -- EQ3 --\n
!!
!!                 and the dependency from the previous timestep is hidden in
!!                 soilcap and soilflux (apparent surface heat capacity and heat
!!                 flux respectively). Soilcap and soilflux are therefore
!!                 calculated at the previsou timestep, at the very end of thermosoil
!!                 (final call to thermosoil_coef) and stored to be used at the next time step.
!!                 At timestep t, EQ3 is solved for Ts in enerbil, and Ts
!!                 is used in thermosoil to get T(1) and solve EQ1.\n
!!
!! - lambda is the @tex $\mu$ @endtex of F. Hourdin' s PhD thesis, equation (A28); ie the
!! coefficient of the linear extrapolation of Ts (surface temperature) from T1 and T2 (ptn(jg=1) and ptn(jg=2)), so that:\n
!! Ts= (1+lambda)*T(1)-lambda*T(2) --EQ2-- \n
!! lambda = (zz_coeff(1))/((zz_coef(2)-zz_coef(1))) \n
!!
!! - cstgrnd is the attenuation depth of the diurnal temperature signal
!! (period : one_day) as a result of the heat conduction equation
!! with no coefficients :
!!\latexonly
!!\input{thermosoil_var_init0.tex}
!!\endlatexonly
!!  -- EQ4 --\n
!! This equation results from the change of variables :
!! z' =z*sqrt(Cp/K) where z' is the new depth (homogeneous
!! to sqrt(time) ), z the real depth (in m), Cp and K the soil heat
!! capacity and conductivity respectively.\n
!!
!! the attenuation depth of a diurnal thermal signal for EQ4 is therefore homogeneous to sqrt(time) and
!! equals : \n
!! cstgrnd = sqrt(oneday/Pi)
!!
!! - lskin is the attenuation depth of the diurnal temperature signal
!! (period : one_day) within the soil for the complete heat conduction equation
!! (ie : with coefficients)
!!\latexonly
!!\input{thermosoil_var_init00.tex}
!!\endlatexonly
!! -- EQ5 --  \n
!! it can be retrieved from cstgrnd using the change of variable  z' =z*sqrt(Cp/K):\n
!! lskin = sqrt(K/Cp)*cstgrnd =  sqrt(K/Cp)*sqrt(oneday//Pi)\n
!! 
!! In thermosoil, the ratio lskin/cstgrnd is frequently used as the
!! multiplicative factor to go from
!!'adimensional' depths (like z' ) to real depths (z). z' is not really
!! adimensional but is reffered to like this in the code.
!!
!!
!! RECENT CHANGE(S) : None
!!
!! REFERENCE(S) : None
!!
!! SVN          :
!! $HeadURL$
!! $Date$
!! $Revision$
!! \n
!_ ================================================================================================================================

MODULE thermosoil

  ! modules used :
  USE ioipsl
  USE ioipsl_para
  USE xios_orchidee
  USE constantes
  USE constantes_soil
  USE sechiba_io
  USE grid


  IMPLICIT NONE

  !private and public routines :
  PRIVATE
  PUBLIC :: thermosoil_main, thermosoil_clear, thermosoil_levels

  LOGICAL, SAVE                                   :: l_first_thermosoil=.TRUE.!! does the initialisation of the routine 
                                                                              !! (true/false)
!$OMP THREADPRIVATE(l_first_thermosoil)
  CHARACTER(LEN=80) , SAVE                        :: var_name                 !! To store variables names for the 
                                                                              !! input-outputs dealt with by IOIPSL
!$OMP THREADPRIVATE(var_name)
  REAL(r_std), SAVE                               :: lambda, cstgrnd, lskin   !! See Module description
!$OMP THREADPRIVATE(lambda, cstgrnd, lskin)
  REAL(r_std), SAVE                               :: fz1, zalph               !! usefull constants for diverse use
!$OMP THREADPRIVATE(fz1, zalph)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:,:) :: ptn                      !! vertically discretized 
                                                                              !! soil temperatures @tex ($K$) @endtex. 
!$OMP THREADPRIVATE(ptn)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:)   :: zz                       !! depths of the soil thermal numerical nodes. 
                                                                              !! Caveats: they are not exactly the centers of the
                                                                              !! thermal layers, see the calculation in 
                                                                              !! ::thermosoil_var_init  @tex ($m$) @endtex.
!$OMP THREADPRIVATE(zz)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:)   :: zz_coef		      !! depths of the boundaries of the thermal layers,
                                                                              !! see the calculation in 
                                                                              !! thermosoil_var_init  @tex ($m$) @endtex.
!$OMP THREADPRIVATE(zz_coef)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:)   :: dz1                      !! numerical constant used in the thermal numerical
                                                                              !! scheme  @tex ($m^{-1}$) @endtex. ; it corresponds
                                                                              !! to the coefficient  @tex $d_k$ @endtex of equation
                                                                              !! (A.12) in F. Hourdin PhD thesis.
!$OMP THREADPRIVATE(dz1)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:)   :: dz2                      !! thicknesses of the thermal layers  @tex ($m$)
                                                                              !! @endtex; typically: 
                                                                              !! dz2(jg)=zz_coef(jg+1)-zz_coef(jg); calculated once 
                                                                              !! and for all in thermosoil_var_init
!$OMP THREADPRIVATE(dz2)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:)   :: z1                       !! constant of the numerical scheme; it is an 
                                                                              !! intermediate buffer for the calculation of the 
                                                                              !! integration coefficients cgrnd and dgrnd.
!$OMP THREADPRIVATE(z1)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:,:) :: cgrnd                    !! integration coefficient for the numerical scheme,
                                                                              !! see eq.1
!$OMP THREADPRIVATE(cgrnd)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:,:) :: dgrnd                    !! integration coefficient for the numerical scheme,
                                                                              !! see eq.1
!$OMP THREADPRIVATE(dgrnd)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:,:) :: pcapa                    !! volumetric vertically discretized soil heat 
                                                                              !! capacity  @tex ($J K^{-1} m^{-3}$) @endtex. 
                                                                              !! It depends on the soil
                                                                              !! moisture content (shum_ngrnd_perma) and is calculated at 
                                                                              !! each time step in thermosoil_coef.
!$OMP THREADPRIVATE(pcapa)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:,:) :: pkappa                   !! vertically discretized soil thermal conductivity 
                                                                              !!  @tex ($W K^{-1} m^{-1}$) @endtex. Same as pcapa.
!$OMP THREADPRIVATE(pkappa)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:,:) :: zdz1                     !! numerical constant of the numerical scheme; it is
                                                                              !! an intermediate buffer for the calculation of the 
                                                                              !! integration coefficients cgrnd and dgrnd 
                                                                              !!  @tex ($W K^{-1} m^{-1}$) @endtex 
!$OMP THREADPRIVATE(zdz1)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:,:) :: zdz2                     !! numerical constant of the numerical scheme; it is 
                                                                              !! an intermediate buffer for the calculation of the 
                                                                              !! integration coefficients cgrnd and dgrnd
                                                                              !!  @tex ($W K^{-1} m^{-1}$) @endtex
!$OMP THREADPRIVATE(zdz2)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:,:) :: pcapa_en                 !! heat capacity used for surfheat_incr and 
                                                                              !! coldcont_incr 
!$OMP THREADPRIVATE(pcapa_en)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:,:) :: ptn_beg                  !! vertically discretized temperature at the 
                                                                              !! beginning of the time step  @tex ($K$) @endtex; 
                                                                              !! is used in 
                                                                              !! thermosoil_energy for energy-related diagnostic of
                                                                              !! the routine.
!$OMP THREADPRIVATE(ptn_beg)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:)   :: temp_sol_beg             !! Surface temperature at the beginning of the 
                                                                              !! timestep  @tex ($K$) @endtex
!$OMP THREADPRIVATE(temp_sol_beg)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:)   :: surfheat_incr            !! Change in soil heat content during the timestep 
                                                                              !!  @tex ($J$) @endtex.
!$OMP THREADPRIVATE(surfheat_incr)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:)   :: coldcont_incr            !! Change in snow heat content  @tex ($J$) @endtex.
!$OMP THREADPRIVATE(coldcont_incr)
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:,:) :: shum_ngrnd_perma         !! Saturation degree on the thermal axes (0-1, dimensionless)
!$OMP THREADPRIVATE(shum_ngrnd_perma)

  !  Variables related to soil freezing
  REAL(r_std), ALLOCATABLE, SAVE, DIMENSION (:,:) :: profil_froz              !! Frozen fraction of the soil on hydrological levels (-)
!$OMP THREADPRIVATE(profil_froz)
  REAL(r_std),ALLOCATABLE, SAVE, DIMENSION (:) :: e_soil_lat                  !! Accumulated latent heat for the whole soil (J)
!$OMP THREADPRIVATE(e_soil_lat)
  REAL(r_std), ALLOCATABLE, SAVE,DIMENSION(:) :: overburden                   !! Information read from IPA map for option read_permafrost_map
!$OMP THREADPRIVATE(overburden)
  REAL(r_std), ALLOCATABLE, SAVE,DIMENSION(:) :: excess_ice                   !! Information read from IPA map for option read_permafrost_map
!$OMP THREADPRIVATE(excess_ice)
  REAL(r_std), ALLOCATABLE, SAVE,DIMENSION(:) :: permafrost                   !! Information read from IPA map for option read_permafrost_map
!$OMP THREADPRIVATE(permafrost)
  REAL(r_std),ALLOCATABLE, SAVE, DIMENSION (:,:) :: pcappa_supp               !! Additional heat capacity due to soil freezing for each soil layer (J/K)
!$OMP THREADPRIVATE(pcappa_supp)    


CONTAINS

!! ================================================================================================================================
!! SUBROUTINE   : thermosoil_main
!!
!>\BRIEF        Thermosoil_main computes the soil thermal properties and dynamics, ie solves
!! the heat diffusion equation within the soil. The soil temperature profile is
!! then interpolated onto the diagnostic axis.
!!
!! DESCRIPTION : The resolution of the soil heat diffusion equation 
!! relies on a numerical finite-difference implicit scheme
!! fully described in the reference and in the header of the thermosoil module.
!! - The dependency of the previous timestep hidden in the 
!! integration coefficients cgrnd and dgrnd (EQ1), calculated in thermosoil_coef, and 
!! called at the end of the routine to prepare for the next timestep.
!! - The effective computation of the new soil temperatures is performed in thermosoil_profile. 
!!
!! - The calling sequence of thermosoil_main is summarized in the flowchart below.
!! - Thermosoil_init and thermosoil_var_init initialize the variables from
!! restart files or with default values; they also set up
!! the vertical discretization for the numerical scheme.
!! - thermosoil_coef calculates the coefficients for the numerical scheme for the very first iteration of thermosoil;
!! after that, thermosoil_coef is called only at the end of the module to calculate the coefficients for the next timestep.
!! - thermosoil_profile solves the numerical scheme.\n
!!
!! - Flags : one unique flag : THERMOSOIL_TPRO (to be set to the desired initial soil in-depth temperature in K; by default 280K)
!!
!! RECENT CHANGE(S) : None
!!
!! MAIN OUTPUT VARIABLE(S): vertically discretized soil temperatures ptn, soil
!! thermal properties (pcapa, pkappa), apparent surface heat capacity (soilcap)
!! and heat flux (soilflux) to be used in enerbil at the next timestep to solve
!! the surface energy balance.
!!
!! REFERENCE(S) : 
!! - Hourdin, F. (1992). Study and numerical simulation of the general circulation of planetary atmospheres,
!!  Ph.D. thesis, Paris VII University. Remark: the part of F. Hourdin' s PhD thesis relative to the thermal
!!  integration scheme has been scanned and is provided along with the documentation, with name : 
!!  Hourdin_1992_PhD_thermal_scheme.pdf
!!
!! FLOWCHART    : 
!! \latexonly
!! \includegraphics[scale = 1]{thermosoil_flowchart.png}
!! \endlatexonly
!! 
!! \n
!_ ================================================================================================================================

  SUBROUTINE thermosoil_main (kjit, kjpindex, dtradia, &
       ldrestart_read,   ldrestart_write, index, indexgrnd, &
       indexnbdl, control_in, &
       temp_sol_new, snow, soilcap, soilflx, &
       shumdiag_perma, stempdiag, ptnlev1, rest_id, hist_id, hist2_id, &
       soiltemp,pb,grndflux,snowrho,snowdz,snowtemp,gthick,gtemp,gpkappa,&
       pkappa_snow,snowdz_o)

    !! 0. Variable and parameter declaration

    !! 0.1 Input variables

    INTEGER(i_std), INTENT(in)                            :: kjit             !! Time step number (unitless) 
    INTEGER(i_std), INTENT(in)                            :: kjpindex         !! Domain size (unitless)
    INTEGER(i_std),INTENT (in)                            :: rest_id,hist_id  !! Restart_ file and history file identifier 
                                                                              !! (unitless)
    INTEGER(i_std),INTENT (in)                            :: hist2_id         !! history file 2 identifier (unitless)
    REAL(r_std), INTENT (in)                              :: dtradia          !! model iteration time step in seconds (s)
    LOGICAL, INTENT(in)                                   :: ldrestart_read   !! Logical for restart files to be read 
                                                                              !! (true/false)
    LOGICAL, INTENT(in)                                   :: ldrestart_write  !! Logical for restart files to be writen 
                                                                              !! (true/false)
    INTEGER(i_std),DIMENSION (kjpindex), INTENT (in)      :: index            !! Indeces of the points on the map (unitless)
    INTEGER(i_std),DIMENSION (kjpindex*ngrnd), INTENT (in):: indexgrnd        !! Indeces of the points on the 3D map (vertical 
                                                                              !! dimension towards the ground) (unitless)
    REAL(r_std),DIMENSION (kjpindex), INTENT (in)         :: temp_sol_new     !! Surface temperature at the present time-step,
                                                                              !! Ts @tex ($K$) @endtex
    REAL(r_std),DIMENSION (kjpindex), INTENT (in)         :: snow             !! Snow mass @tex ($kg$) @endtex.
                                                                              !! Caveat: when there is snow on the
                                                                              !! ground, the snow is integrated into the soil for
                                                                              !! the calculation of the thermal dynamics. It means
                                                                              !! that the uppermost soil layers can completely or 
                                                                              !! partially consist in snow. In the second case, zx1
                                                                              !! and zx2 are the fraction of the soil layer 
                                                                              !! consisting in snow and 'normal' soil, respectively
                                                                              !! This is calculated in thermosoil_coef.
    REAL(r_std),DIMENSION (kjpindex,nbdl), INTENT (in)    :: shumdiag_perma   !! Soil saturation degree on the diagnostic axis (0-1, unitless)
    INTEGER(i_std),DIMENSION (kjpindex*nbdl), INTENT (in) :: indexnbdl        !! Indeces of the points on the 3D map
    TYPE(control_type), INTENT (in)                       :: control_in       !! Flags that (de)activate parts of the model    
    REAL(r_std),DIMENSION (kjpindex),INTENT(in)           :: pb               !! Surface pressure
    REAL(r_std),DIMENSION (kjpindex,nsnow),INTENT (in)    :: snowrho          !! Snow density
    REAL(r_std),DIMENSION (kjpindex,nsnow),INTENT (in)    :: snowdz           !! Snow depth
    REAL(r_std),DIMENSION (kjpindex,nsnow),INTENT (in)    :: snowtemp         !! Snow temperature
    REAL(r_std),DIMENSION (kjpindex,nsnow),INTENT (in)    :: snowdz_o         !! Snow depth at previous time step
    REAL(r_std),DIMENSION(kjpindex,nsnow),INTENT(in)      :: pkappa_snow      !! Snow thermal conductivity


    !! 0.2 Output variables

    REAL(r_std),DIMENSION (kjpindex), INTENT (out)        :: ptnlev1          !! 1st level soil temperature   
    REAL(r_std),DIMENSION (kjpindex,ngrnd),INTENT(out)    :: soiltemp         !! soil temperature profile
    REAL(r_std),DIMENSION (kjpindex),INTENT(out)          :: gthick           !! First soil layer thickness
    REAL(r_std),DIMENSION (kjpindex),INTENT(out)          :: gtemp            !! First soil layer temperature
    REAL(r_std),DIMENSION (kjpindex),INTENT(out)          :: gpkappa          !! First soil layer thermal conductivity


    !! 0.3 Modified variables

    REAL(r_std),DIMENSION (kjpindex), INTENT (inout)      :: soilcap          !! apparent surface heat capacity
                                                                              !! @tex ($J m^{-2} K^{-1}$) @endtex
    REAL(r_std),DIMENSION (kjpindex), INTENT (inout)      :: soilflx          !! apparent soil heat flux @tex ($W m^{-2}$) @endtex
                                                                              !! , positive 
                                                                              !! towards the soil, writen as Qg (ground heat flux) 
                                                                              !! in the history files, and computed at the end of 
                                                                              !! thermosoil for the calculation of Ts in enerbil, 
                                                                              !! see EQ3.
    REAL(r_std),DIMENSION (kjpindex,nbdl), INTENT (inout) :: stempdiag        !! diagnostic temperature profile @tex ($K$) @endtex
                                                                              !! , eg on the 
                                                                              !! diagnostic axis (levels:1:nbdl). The soil 
                                                                              !! temperature is put on this diagnostic axis to be
                                                                              !! used by other modules (slowproc.f90; routing.f90;
                                                                              !! hydrol or hydrolc when a frozen soil 
                                                                              !! parametrization is used..)
    REAL(r_std),DIMENSION (kjpindex),INTENT(inout)        :: grndflux         !! Net flux into the soil 



    !! 0.4 Local variables

    REAL(r_std),DIMENSION (kjpindex,ngrnd)                :: temp             !! buffer
    REAL(r_std),DIMENSION (kjpindex,ngrnd-1)              :: temp1            !! buffer
    REAL(r_std),DIMENSION (kjpindex)                      :: temp2            !! buffer
    CHARACTER(LEN=80)                                     :: var_name         !! To store variables names for I/O
    INTEGER(i_std)                                        :: jv,ji,ii

!_ ================================================================================================================================
    
  !! 1. do initialisation
    
    IF (l_first_thermosoil) THEN

        IF (long_print) WRITE (numout,*) ' l_first_thermosoil : call thermosoil_init '

        
        !! 1.1. Allocate and initialize soil temperatures variables
        !! by reading restart files or using default values. 
        CALL thermosoil_init (kjit, ldrestart_read, kjpindex, index, rest_id, &
             snowdz)

       
        !! 1.2.Computes physical constants and arrays; initializes soil thermal properties; produces the first stempdiag
        !!  Computes some physical constants and arrays depending on the soil vertical discretization 
        !! (lskin, cstgrnd, zz, zz_coef, dz1, dz2); get the vertical humidity onto the thermal levels, and 
        !! initializes soil thermal properties (pkappa, pcapa); produces the first temperature diagnostic stempdiag.
        CALL thermosoil_var_init (kjpindex, zz, zz_coef, dz1, dz2, &
             shumdiag_perma,      stempdiag, snow, &
             pb,      snowtemp,  snowrho)

        
        !! 1.3. Computes cgrd, dgrd, soilflx and soilcap coefficients from restart values or initialisation values.
        CALL thermosoil_coef (&
             kjpindex, dtradia, temp_sol_new, snow, &
             ptn,      soilcap, soilflx,      zz, &
             dz1,      dz2,     z1,           zdz1,&
             zdz2,     cgrnd,   dgrnd)
        
        !! 1.4. call to thermosoil_energy, if you wish to perform some checks (?)
        !!?? the usefulness of this routine seems questionable.
        CALL thermosoil_energy (kjpindex, temp_sol_new, soilcap, .TRUE.)

        !! 1.5. read restart files for other variables than ptn.
        !!?? mind the use of ok_var here.
        !!?? ok_var is a function of sechiba_io_p.f90, documented as follows :
        !!!! pour déclancher les restarts rajoutés avec un paramètre externe
           !!FUNCTION ok_var ( varname )
           !!CHARACTER(LEN=*), INTENT(IN) :: varname
           !!LOGICAL ok_var
           !!ok_var=.FALSE.
           !!CALL getin_p(varname, ok_var)
           !!END FUNCTION ok_var
         !!
         !! from what we understand, it looks for the chain varname in
         !!run.def; if absent, returns .FALSE., and the variable named
         !!'varname' is not searched for in the restart. This looks like a
         !!trick to read variables in restart files when they are not read
         !!there by default. For all variables in the following sequence, ok_var
         !!is by default false, so don' t bother about this.
         !! this is also logical as those variables have been initialized
         !!above.
         !!?? so maybe this part of the code could be deleted to add clarity.
        IF (ldrestart_read) THEN
           IF (long_print) WRITE (numout,*) ' we have to READ a restart file for THERMOSOIL variables'

           var_name= 'cgrnd'
           CALL ioconf_setatt_p('UNITS', '-')
           CALL ioconf_setatt_p('LONG_NAME','Cgrnd coefficient.')
           IF ( ok_var(var_name) ) THEN
              CALL restget_p (rest_id, var_name, nbp_glo, ngrnd-1, 1, kjit, .TRUE., temp1, "gather", nbp_glo, index_g)
              IF (MINVAL(temp1) < MAXVAL(temp1) .OR. MAXVAL(temp1) .NE. val_exp) THEN
                 cgrnd(:,:)=temp1(:,:)
              ENDIF
           ENDIF

           var_name= 'dgrnd'
           CALL ioconf_setatt_p('UNITS', '-')
           CALL ioconf_setatt_p('LONG_NAME','Dgrnd coefficient.')
           IF ( ok_var(var_name) ) THEN
              CALL restget_p (rest_id, var_name, nbp_glo, ngrnd-1, 1, kjit, .TRUE., temp1, "gather", nbp_glo, index_g)
              IF (MINVAL(temp1) < MAXVAL(temp1) .OR. MAXVAL(temp1) .NE. val_exp) THEN
                 dgrnd(:,:)=temp1(:,:)
              ENDIF
           ENDIF

           var_name= 'z1'
           CALL ioconf_setatt_p('UNITS', '-')
           CALL ioconf_setatt_p('LONG_NAME','?.')
           IF ( ok_var(var_name) ) THEN
              CALL restget_p (rest_id, var_name, nbp_glo, 1, 1, kjit, .TRUE., temp2, "gather", nbp_glo, index_g)
              IF (MINVAL(temp2) < MAXVAL(temp2) .OR. MAXVAL(temp2) .NE. val_exp) THEN
                 z1(:)=temp2(:)
              ENDIF
           ENDIF

           var_name= 'pcapa'
           CALL ioconf_setatt_p('UNITS', '-')
           CALL ioconf_setatt_p('LONG_NAME','?.')
           IF ( ok_var(var_name) ) THEN
              CALL restget_p (rest_id, var_name, nbp_glo, ngrnd, 1, kjit, .TRUE., temp, "gather", nbp_glo, index_g)
              IF (MINVAL(temp) < MAXVAL(temp) .OR. MAXVAL(temp) .NE. val_exp) THEN
                 pcapa(:,:)=temp(:,:)
              ENDIF
           ENDIF

           var_name= 'pcapa_en'
           CALL ioconf_setatt_p('UNITS', '-')
           CALL ioconf_setatt_p('LONG_NAME','?.')
           IF ( ok_var(var_name) ) THEN
              CALL restget_p (rest_id, var_name, nbp_glo, ngrnd, 1, kjit, .TRUE., temp, "gather", nbp_glo, index_g)
              IF (MINVAL(temp) < MAXVAL(temp) .OR. MAXVAL(temp) .NE. val_exp) THEN
                 pcapa_en(:,:)=temp(:,:)
              ENDIF
           ENDIF

           var_name= 'pkappa'
           CALL ioconf_setatt_p('UNITS', '-')
           CALL ioconf_setatt_p('LONG_NAME','?.')
           IF ( ok_var(var_name) ) THEN
              CALL restget_p (rest_id, var_name, nbp_glo, ngrnd, 1, kjit, .TRUE., temp, "gather", nbp_glo, index_g)
              IF (MINVAL(temp) < MAXVAL(temp) .OR. MAXVAL(temp) .NE. val_exp) THEN
                 pkappa(:,:)=temp(:,:)
              ENDIF
           ENDIF

           var_name= 'zdz1'
           CALL ioconf_setatt_p('UNITS', '-')
           CALL ioconf_setatt_p('LONG_NAME','?.')
           IF ( ok_var(var_name) ) THEN
              CALL restget_p (rest_id, var_name, nbp_glo, ngrnd-1, 1, kjit, .TRUE., temp1, "gather", nbp_glo, index_g)
              IF (MINVAL(temp1) < MAXVAL(temp1) .OR. MAXVAL(temp1) .NE. val_exp) THEN
                 zdz1(:,:)=temp1(:,:)
              ENDIF
           ENDIF

           var_name= 'zdz2'
           CALL ioconf_setatt_p('UNITS', '-')
           CALL ioconf_setatt_p('LONG_NAME','?.')
           IF ( ok_var(var_name) ) THEN
              CALL restget_p (rest_id, var_name, nbp_glo, ngrnd, 1, kjit, .TRUE., temp, "gather", nbp_glo, index_g)
              IF (MINVAL(temp) < MAXVAL(temp) .OR. MAXVAL(temp) .NE. val_exp) THEN
                 zdz2(:,:)=temp(:,:)
              ENDIF
           ENDIF

           var_name='temp_sol_beg'
           CALL ioconf_setatt_p('UNITS', 'K')
           CALL ioconf_setatt_p('LONG_NAME','Old Surface temperature')
           IF ( ok_var(var_name) ) THEN
              CALL restget_p (rest_id, var_name, nbp_glo, 1, 1, kjit, .TRUE., temp2, "gather", nbp_glo, index_g)
              IF (MINVAL(temp2) < MAXVAL(temp2) .OR. MAXVAL(temp2) .NE. val_exp) THEN
                 temp_sol_beg(:) = temp2(:)
              ENDIF
           ENDIF

        ENDIF !ldrestart_read

        RETURN 

    ENDIF !l_first_thermosoil

    
  !! 2. Prepares the restart files for the next simulation

    !!?? do all the coefficients (cgrnd, dgrnd...) be put in the restart file
    !! as they are by default not read there, but calculated in
    !!thermosoil_var_init from the restart or initial temperature ?
    !! exceptions are soilcap and soilflx, used in enerbil, and of course ptn.
    IF (ldrestart_write) THEN

        IF (long_print) WRITE (numout,*) ' we have to complete restart file with THERMOSOIL variables'

        var_name= 'ptn'
        CALL restput_p(rest_id, var_name, nbp_glo, ngrnd, 1, kjit, ptn, 'scatter', nbp_glo, index_g)

        IF (ok_Ecorr) THEN
           var_name= 'e_soil_lat'
           CALL restput_p(rest_id, var_name, nbp_glo, 1 , 1, kjit, e_soil_lat, 'scatter', nbp_glo, index_g)
        END IF

        var_name= 'cgrnd'
        CALL restput_p(rest_id, var_name, nbp_glo, ngrnd-1, 1, kjit, cgrnd, 'scatter', nbp_glo, index_g)
        var_name= 'dgrnd'
        CALL restput_p(rest_id, var_name, nbp_glo, ngrnd-1, 1, kjit, dgrnd, 'scatter', nbp_glo, index_g)

        var_name= 'z1'
        CALL restput_p(rest_id, var_name, nbp_glo, 1, 1, kjit, z1, 'scatter', nbp_glo, index_g)

        var_name= 'pcapa'
        CALL restput_p(rest_id, var_name, nbp_glo, ngrnd, 1, kjit, pcapa, 'scatter', nbp_glo, index_g)

        var_name= 'pcapa_en'
        CALL restput_p(rest_id, var_name, nbp_glo, ngrnd, 1, kjit, pcapa_en, 'scatter', nbp_glo, index_g)

        var_name= 'pkappa'
        CALL restput_p(rest_id, var_name, nbp_glo, ngrnd, 1, kjit, pkappa, 'scatter', nbp_glo, index_g)

        var_name= 'zdz1'
        CALL restput_p(rest_id, var_name, nbp_glo, ngrnd-1, 1, kjit, zdz1, 'scatter', nbp_glo, index_g)

        var_name= 'zdz2'
        CALL restput_p(rest_id, var_name, nbp_glo, ngrnd, 1, kjit, zdz2, 'scatter', nbp_glo, index_g)

        var_name= 'temp_sol_beg'
        CALL restput_p(rest_id, var_name, nbp_glo, 1, 1, kjit, temp_sol_beg, 'scatter', nbp_glo, index_g)

        var_name= 'soilcap'  
        CALL restput_p(rest_id, var_name, nbp_glo,   1, 1, kjit,  soilcap, 'scatter',  nbp_glo, index_g)
        
        var_name= 'soilflx'  
        CALL restput_p(rest_id, var_name, nbp_glo,   1, 1, kjit,  soilflx, 'scatter',  nbp_glo, index_g)

        ! read in enerbil
        var_name= 'temp_sol_new'
        CALL restput_p(rest_id, var_name, nbp_glo, 1, 1, kjit, temp_sol_new, 'scatter', nbp_glo, index_g)

        RETURN 

    END IF !ldrestart_write

  !! 3. Put the soil wetness diagnostic on the levels of the soil temperature

    !!?? this could logically be put just before the last call to
    !!thermosoil_coef, as the results are used there...
    CALL thermosoil_humlev(kjpindex, shumdiag_perma, snow)

    
  !! 4. Effective computation of the soil temperatures profile, using the cgrd and dgrd coefficients from previsou tstep.
    
    CALL thermosoil_profile (kjpindex, temp_sol_new, ptn,  &
         stempdiag,pkappa_snow,snowdz_o,snowtemp,grndflux,dtradia)

  !! 5. Call to thermosoil_energy, still to be clarified..

    CALL thermosoil_energy (kjpindex, temp_sol_new, soilcap, .FALSE.)

  !! 6. Writing the history files according to the ALMA standards (or not..)

    !in only one file (hist2_id <=0) or in 2 different files (hist2_id >0).
    CALL xios_orchidee_send_field("ptn",ptn)
    CALL xios_orchidee_send_field("Qg",soilflx)
    CALL xios_orchidee_send_field("DelSurfHeat",surfheat_incr)
    CALL xios_orchidee_send_field("DelColdCont",coldcont_incr)

    IF ( .NOT. almaoutput ) THEN
      CALL histwrite_p(hist_id, 'ptn', kjit, ptn, kjpindex*ngrnd, indexgrnd)
      CALL histwrite_p(hist_id, 'Qg', kjit, soilflx, kjpindex, index)

      IF ( control_in%hydrol_cwrr ) THEN
         CALL histwrite_p(hist_id, 'ptn_beg', kjit, ptn_beg, kjpindex*ngrnd, indexgrnd)
         CALL histwrite_p(hist_id, 'profil_froz', kjit, profil_froz, kjpindex*ngrnd, indexgrnd)
         CALL histwrite_p(hist_id, 'pkappa', kjit, pkappa, kjpindex*ngrnd, indexgrnd)
         CALL histwrite_p(hist_id, 'pcapa', kjit, pcapa, kjpindex*ngrnd, indexgrnd)
         CALL histwrite_p(hist_id, 'pcappa_supp', kjit, pcappa_supp, kjpindex*ngrnd, indexgrnd)
         CALL histwrite_p(hist_id, 'shum_ngrnd_perma', kjit, shum_ngrnd_perma(:,:), kjpindex*ngrnd, indexgrnd)
         CALL histwrite_p(hist_id, 'stempdiag', kjit, stempdiag, kjpindex*nbdl, indexnbdl)
      END IF

    ELSE
      CALL histwrite_p(hist_id, 'SoilTemp', kjit, ptn, kjpindex*ngrnd, indexgrnd)
      CALL histwrite_p(hist_id, 'Qg', kjit, soilflx, kjpindex, index)
      CALL histwrite_p(hist_id, 'DelSurfHeat', kjit, surfheat_incr, kjpindex, index)
      CALL histwrite_p(hist_id, 'DelColdCont', kjit, coldcont_incr, kjpindex, index)
    ENDIF
    IF ( hist2_id > 0 ) THEN
       IF ( .NOT. almaoutput ) THEN
          CALL histwrite_p(hist2_id, 'ptn', kjit, ptn, kjpindex*ngrnd, indexgrnd)
       ELSE
          CALL histwrite_p(hist2_id, 'SoilTemp', kjit, ptn, kjpindex*ngrnd, indexgrnd)
          CALL histwrite_p(hist2_id, 'Qg', kjit, soilflx, kjpindex, index)
          CALL histwrite_p(hist2_id, 'DelSurfHeat', kjit, surfheat_incr, kjpindex, index)
          CALL histwrite_p(hist2_id, 'DelColdCont', kjit, coldcont_incr, kjpindex, index)
       ENDIF
    ENDIF
    
  !! 7. A last final call to thermosoil_coef
 
    !! A last final call to thermosoil_coef, which calculates the different
    !!coefficients (cgrnd, dgrnd, dz1, z1, zdz2, soilcap, soilflx) from this time step to be
    !!used at the next time step, either in the surface temperature calculation
    !!(soilcap, soilflx) or in the soil thermal numerical scheme.
    CALL thermosoil_coef (&
         kjpindex, dtradia, temp_sol_new, snow, &
         ptn,      soilcap, soilflx,      zz,   &
         dz1,      dz2,     z1,           zdz1, &
         zdz2,     cgrnd,   dgrnd)

    ! Save variables for explicit snow model
    gthick(:) = zz_coef(1)
    gtemp(:) = ptn(:,1)
    gpkappa(:)=pkappa(:,1)
    grndflux(:)=0.0
           
    !! Initialize output arguments to be used in sechiba
    soiltemp = ptn
    ptnlev1(:) = ptn(:,1)

    IF (long_print) WRITE (numout,*) ' thermosoil_main done '

  END SUBROUTINE thermosoil_main


!! ================================================================================================================================
!! SUBROUTINE   : thermosoil_init
!!
!>\BRIEF        Allocates local and global arrays; initializes soil temperatures using either restart files
!! or a fixed value set by the flag THERMOSOIL_TPRO.
!!		  
!! DESCRIPTION  : flag : THERMOSOIL_TPRO (to be set to the desired initial temperature in K; by default 280K).
!!
!! RECENT CHANGE(S) : None 
!!
!! MAIN OUTPUT VARIABLE(S): None
!!
!! REFERENCE(S) : None 
!!
!! FLOWCHART    : None
!! \n
!_ ================================================================================================================================

  SUBROUTINE thermosoil_init(kjit, ldrestart_read, kjpindex, index, rest_id, &
       snowdz)
    
    !! 0. Variable and parameter declaration

    !! 0.1 Input variables
    
    INTEGER(i_std), INTENT (in)                         :: kjit               !! Time step number (unitless) 
    LOGICAL,INTENT (in)                                 :: ldrestart_read     !! Logical for restart file to read (true/false)
    INTEGER(i_std), INTENT (in)                         :: kjpindex           !! Domain size (unitless)
    INTEGER(i_std),DIMENSION (kjpindex), INTENT (in)    :: index              !! Indeces of the points on the map (unitless)
    INTEGER(i_std), INTENT (in)                         :: rest_id            !! Restart file identifier (unitless)
    REAL(r_std),DIMENSION (kjpindex,nsnow),INTENT (in)  :: snowdz
    
    !! 0.2 Output variables

    !! 0.3 Modified variables

    !! 0.4 Local variables

    INTEGER(i_std)                                     :: ier, i
    INTEGER(i_std)                                     :: jv,ji
    REAL(r_std),DIMENSION (kjpindex,ngrnd)             :: reftemp             !! Reference temperature read from file if read_reftemp activated
    CHARACTER(LEN=80)                                  :: var_name            !! To store variables names for I/O

!_ ================================================================================================================================

  !! 1. Initialisation

    !! Initialisation has to be done only one time, so the logical
    !! logical l_first_thermosoil has to be set to .FALSE. now..
    IF (l_first_thermosoil) THEN 
        l_first_thermosoil=.FALSE.
    ELSE 
        WRITE (numout,*) ' l_first_thermosoil false . we stop '
        STOP 'thermosoil_init'
    ENDIF

  !! 2. Arrays allocations

    ALLOCATE (ptn(kjpindex,ngrnd),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in ptn allocation. We stop. We need ',kjpindex,' fois ',ngrnd,' words = '&
           & , kjpindex*ngrnd
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (zz(ngrnd),stat=ier)
    IF (ier /= 0) THEN
       CALL ipslerr_p(3,'thermosoil_init', 'Error in allocation of zz','','')
    END IF

    ALLOCATE (zz_coef(ngrnd),stat=ier)
    IF (ier /= 0) THEN
       CALL ipslerr_p(3,'thermosoil_init', 'Error in allocation of zz_coef','','')
    END IF

    ALLOCATE (dz1(ngrnd),stat=ier)
    IF (ier /= 0) THEN
       CALL ipslerr_p(3,'thermosoil_init', 'Error in allocation of dz1','','')
    END IF

    ALLOCATE (dz2(ngrnd),stat=ier)
    IF (ier /= 0) THEN
       CALL ipslerr_p(3,'thermosoil_init', 'Error in allocation of dz2','','')
    END IF

    ALLOCATE (z1(kjpindex),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in z1 allocation. We STOP. We need ',kjpindex,' words '
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (cgrnd(kjpindex,ngrnd-1),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in cgrnd allocation. We STOP. We need ',kjpindex,' fois ',ngrnd-1 ,' words  = '&
           & , kjpindex*(ngrnd-1)
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (dgrnd(kjpindex,ngrnd-1),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in dgrnd allocation. We STOP. We need ',kjpindex,' fois ',ngrnd-1 ,' words  = '&
           & , kjpindex*(ngrnd-1)
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (pcapa(kjpindex,ngrnd),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in pcapa allocation. We STOP. We need ',kjpindex,' fois ',ngrnd ,' words  = '&
           & , kjpindex*ngrnd
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (pkappa(kjpindex,ngrnd),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in pkappa allocation. We STOP. We need ',kjpindex,' fois ',ngrnd ,' words  = '&
           & , kjpindex*ngrnd
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (zdz1(kjpindex,ngrnd-1),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in zdz1 allocation. We STOP. We need ',kjpindex,' fois ',ngrnd-1 ,' words  = '&
           & , kjpindex*(ngrnd-1)
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (zdz2(kjpindex,ngrnd),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in zdz2 allocation. We STOP. We need ',kjpindex,' fois ',ngrnd ,' words  = '&
           & , kjpindex*ngrnd
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (surfheat_incr(kjpindex),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in surfheat_incr allocation. We STOP. We need ',kjpindex,' words  = '&
           & , kjpindex
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (coldcont_incr(kjpindex),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in coldcont_incr allocation. We STOP. We need ',kjpindex,' words  = '&
           & , kjpindex
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (pcapa_en(kjpindex,ngrnd),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in pcapa_en allocation. We STOP. We need ',kjpindex,' fois ',ngrnd ,' words  = '&
           & , kjpindex*ngrnd
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (ptn_beg(kjpindex,ngrnd),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in ptn_beg allocation. We STOP. We need ',kjpindex,' fois ',ngrnd ,' words  = '&
           & , kjpindex*ngrnd
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (temp_sol_beg(kjpindex),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in temp_sol_beg allocation. We STOP. We need ',kjpindex,' words  = '&
           & , kjpindex
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (shum_ngrnd_perma(kjpindex,ngrnd),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in shum_ngrnd_perma allocation. We STOP. We need ',kjpindex,' fois ',ngrnd ,' words  = '&
           & , kjpindex*ngrnd
        STOP 'thermosoil_init'
    END IF

    ALLOCATE (profil_froz(kjpindex,ngrnd),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in pcapa_en allocation. We STOP. We need ',kjpindex,' fois ',ngrnd ,' words  = '&
           & , kjpindex*ngrnd
        STOP 'thermosoil_init'
    END IF

    
    ALLOCATE (pcappa_supp(kjpindex,ngrnd),stat=ier)
    IF (ier.NE.0) THEN
        WRITE (numout,*) ' error in pcapa_supp allocation. We STOP. We need ',kjpindex,' fois ',ngrnd ,' words  = '&
           & , kjpindex*ngrnd
        STOP 'thermosoil_init'
    END IF
    
    IF (ok_Ecorr) THEN
       ALLOCATE (e_soil_lat(kjpindex),stat=ier)
       IF (ier.NE.0) THEN
          WRITE (numout,*) ' error in e_soil_lat allocation. We STOP. We need ',kjpindex,' words  = '&
               & , kjpindex
          STOP 'thermosoil_init'
       END IF
    END IF

    IF (read_permafrost_map) THEN
       ALLOCATE (permafrost(kjpindex),stat=ier)
       IF (ier.NE.0) THEN
          WRITE (numout,*) ' error in permafrost allocation. We STOP. We need ',kjpindex,' fois ',ngrnd ,' words  = '&
               & , kjpindex
          STOP 'thermosoil_init'
       END IF
       ALLOCATE (excess_ice(kjpindex),stat=ier)
       IF (ier.NE.0) THEN
          WRITE (numout,*) ' error in excess_ice allocation. We STOP. We need ',kjpindex,' fois ',ngrnd ,' words  = '&
               & , kjpindex
          STOP 'thermosoil_init'
       END IF

       ALLOCATE (overburden(kjpindex),stat=ier)
       IF (ier.NE.0) THEN
          WRITE (numout,*) ' error in overburden allocation. We STOP. We need ',kjpindex,' fois ',ngrnd ,' words  = '&
               & , kjpindex
          STOP 'thermosoil_init'
       END IF
    END IF
    
  !! 3. Reads restart files for soil temperatures only 
    
    !! Reads restart files for soil temperatures only. If no restart file is
    !! found,  the initial soil temperature is by default set to 280K at all depths. The user
    !! can decide to initialize soil temperatures at an other value, in which case he should set the flag THERMOSOIL_TPRO
    !! to this specific value in the run.def.
    IF (ldrestart_read) THEN
       IF (long_print) WRITE (numout,*) ' we have to READ a restart file for THERMOSOIL variables'

       var_name= 'ptn'
       CALL ioconf_setatt_p('UNITS', 'K')
       CALL ioconf_setatt_p('LONG_NAME','Soil Temperature profile')
       CALL restget_p (rest_id, var_name, nbp_glo, ngrnd, 1, kjit, .TRUE., ptn, "gather", nbp_glo, index_g)
       !
       !Config Key   = THERMOSOIL_TPRO
       !Config Desc  = Initial soil temperature profile if not found in restart
       !Config Def   = 280.
       !Config If    = OK_SECHIBA
       !Config Help  = The initial value of the temperature profile in the soil if 
       !Config         its value is not found in the restart file. This should only 
       !Config         be used if the model is started without a restart file. Here
       !Config         we only require one value as we will assume a constant 
       !Config         throughout the column.
       !Config Units = Kelvin [K]
       !
       
       IF (read_permafrost_map) THEN
          CALL read_permafrostmap(kjpindex,lalo,overburden,excess_ice,permafrost)
       END IF
       
       IF (read_reftemp) THEN
          ! Read variable reftemp from file
          CALL read_reftempfile(kjpindex,lalo,reftemp)
          ! Initialize ptn with reftemp
          CALL setvar_p (ptn, val_exp, 'NO_KEYWORD' ,reftemp)
       ELSE
          CALL setvar_p (ptn, val_exp,'THERMOSOIL_TPRO',280._r_std)
       ENDIF
       
       ! Initialize ptn_beg (variable needed in thermosoil_coef before calucation in thermosoil_energy)
       ptn_beg(:,:) = ptn(:,:)
       
       IF (ok_Ecorr) THEN
          CALL restget_p (rest_id, 'e_soil_lat', nbp_glo, 1, 1, kjit, .TRUE., &
               e_soil_lat, "gather", nbp_glo, index_g)
          CALL setvar_p (e_soil_lat, val_exp,'NO_KEYWORD',zero)
       END IF
    END IF

    IF (long_print) WRITE (numout,*) ' thermosoil_init done '

  END SUBROUTINE thermosoil_init


!! ================================================================================================================================
!! SUBROUTINE   : thermosoil_clear
!!
!>\BRIEF        Sets the flag l_first_thermosoil to true and desallocates the allocated arrays.
!! ??!! the call of thermosoil_clear originates from sechiba_clear but the calling sequence and 
!! its purpose require further investigation.
!!
!! DESCRIPTION  : None
!!
!! RECENT CHANGE(S) : None 
!!
!! MAIN OUTPUT VARIABLE(S): None
!!
!! REFERENCE(S) : None 
!!
!! FLOWCHART    : None
!! \n
!_ ================================================================================================================================

 SUBROUTINE thermosoil_clear()

        l_first_thermosoil=.TRUE.
 
        IF ( ALLOCATED (ptn)) DEALLOCATE (ptn)
        IF ( ALLOCATED (z1)) DEALLOCATE (z1) 
        IF ( ALLOCATED (cgrnd)) DEALLOCATE (cgrnd) 
        IF ( ALLOCATED (dgrnd)) DEALLOCATE (dgrnd) 
        IF ( ALLOCATED (pcapa)) DEALLOCATE (pcapa)
        IF ( ALLOCATED (pkappa))  DEALLOCATE (pkappa)
        IF ( ALLOCATED (zdz1)) DEALLOCATE (zdz1)
        IF ( ALLOCATED (zdz2)) DEALLOCATE (zdz2)
        IF ( ALLOCATED (pcapa_en)) DEALLOCATE (pcapa_en)
        IF ( ALLOCATED (ptn_beg)) DEALLOCATE (ptn_beg)
        IF ( ALLOCATED (temp_sol_beg)) DEALLOCATE (temp_sol_beg)
        IF ( ALLOCATED (surfheat_incr)) DEALLOCATE (surfheat_incr)
        IF ( ALLOCATED (coldcont_incr)) DEALLOCATE (coldcont_incr)
        IF ( ALLOCATED (shum_ngrnd_perma)) DEALLOCATE (shum_ngrnd_perma)
        IF ( ALLOCATED (profil_froz)) DEALLOCATE (profil_froz)

  END SUBROUTINE thermosoil_clear


!! ================================================================================================================================
!! FUNCTION     : fz
!!
!>\BRIEF        fz(rk), the function's result, is the "rk"th element of a geometric series 
!! with first element fz1 and ration zalph.
!!
!! DESCRIPTION  : This function is used to calculate the depths of the boudaries of the thermal layers (zz_coef) and 
!! of the numerical nodes (zz) of the thermal scheme. Formulae to get the adimensional depths are followings :
!!      zz(jg)      = fz(REAL(jg,r_std) - undemi); \n
!!      zz_coef(jg) = fz(REAL(jg,r_std))
!!
!! RECENT CHANGE(S) : None
!!
!! RETURN VALUE : fz(rk)
!!
!! REFERENCE(S) : None 
!!
!! FLOWCHART    : None
!! \n
!_ ================================================================================================================================

  FUNCTION fz(rk) RESULT (fz_result)

  !! 0. Variables and parameter declaration

    !! 0.1 Input variables

    REAL(r_std), INTENT(in)                        :: rk
    
    !! 0.2 Output variables

    REAL(r_std)                                    :: fz_result
    
    !! 0.3 Modified variables

    !! 0.4 Local variables

!_ ================================================================================================================================

    fz_result = fz1 * (zalph ** rk - un) / (zalph - un)

  END FUNCTION fz


!! ================================================================================================================================
!! FUNCTION     : thermosoil_levels
!!
!>\BRIEF          Depth of nodes for the thermal layers in meters. 
!!
!! DESCRIPTION  : Calculate and return the depth in meters of the nodes of the soil layers. This calculation is the same 
!!                as done in thermosoil_var_init for zz. See thermosoil_var_init for more details. 
!!
!! RECENT CHANGE(S) : None
!!
!! RETURN VALUE : Vector of soil depth for the nodes in meters
!!
!! REFERENCE(S) : None 
!!
!! FLOWCHART    : None
!! \n
!_ ================================================================================================================================

  FUNCTION thermosoil_levels() RESULT (zz_out)
    
    !! 0.1 Return variable
    
    REAL(r_std), DIMENSION (ngrnd)  :: zz_out      !! Depth of soil layers in meters
    
    !! 0.2 Local variables
    INTEGER(i_std)                  :: jg
    REAL(r_std)                     :: so_capa
    REAL(r_std)                     :: so_cond
    
!_ ================================================================================================================================

    !! 1. Define some parameters
    so_capa = (so_capa_dry + so_capa_wet)/deux
    so_cond = (so_cond_dry + so_cond_wet)/deux
    
    cstgrnd=SQRT(one_day / pi)
    lskin = SQRT(so_cond / so_capa * one_day / pi)

    !! Parameters needed by fz function
    fz1 = 0.3_r_std * cstgrnd
    zalph = deux

    !!  2. Get adimentional depth of the numerical nodes
    DO jg=1,ngrnd
       zz_out(jg) = fz(REAL(jg,r_std) - undemi)
    ENDDO
    
    !! 3. Convert to meters
    DO jg=1,ngrnd
       zz_out(jg) = zz_out(jg) /  cstgrnd * lskin
    END DO

  END FUNCTION thermosoil_levels


!! ================================================================================================================================
!! SUBROUTINE   : thermosoil_var_init
!!
!>\BRIEF        Define and initializes the soil thermal parameters
!!		  
!! DESCRIPTION	: This routine\n
!! 1. Defines the parameters ruling the vertical grid of the thermal scheme (fz1, zalpha).\n
!! 2. Defines the scaling coefficients for adimensional depths (lskin, cstgrnd, see explanation in the 
!!    variables description of thermosoil_main). \n
!! 3. Calculates the vertical discretization of the soil (zz, zz_coef, dz2) and the constants used
!!    in the numerical scheme and which depend only on the discretization (dz1, lambda).\n
!! 4. Initializes the soil thermal parameters (capacity, conductivity) based on initial soil moisture content.\n
!! 5. Produces a first temperature diagnostic based on temperature initialization.\n
!!
!! The scheme comprizes ngrnd=7 layers by default.
!! The layer' s boundaries depths (zz_coef) follow a geometric series of ratio zalph=2 and first term fz1.\n
!! zz_coef(jg)=fz1.(1-zalph^jg)/(1-zalph) \n
!! The layers' boudaries depths are first calculated 'adimensionally', ie with a
!! discretization adapted to EQ5. This discretization is chosen for its ability at
!! reproducing a thermal signal with periods ranging from days to centuries. (see
!! Hourdin, 1992). Typically, fz1 is chosen as : fz1=0.3*cstgrnd (with cstgrnd the
!! adimensional attenuation depth). \n
!! The factor lskin/cstgrnd is then used to go from adimensional depths to
!! depths in m.\n
!! zz(real)=lskin/cstgrnd*zz(adimensional)\n
!! Similarly, the depths of the numerical nodes are first calculated
!! adimensionally, then the conversion factor is applied.\n
!! the numerical nodes (zz) are not exactly the layers' centers : their depths are calculated as follows:\n
!! zz(jg)=fz1.(1-zalph^(jg-1/2))/(1-zalph)\n
!! The values of zz and zz_coef used in the default thermal discretization are in the following table.
!! \latexonly
!! \includegraphics{thermosoil_var_init1.jpg}
!! \endlatexonly\n
!!
!! RECENT CHANGE(S) : None
!!
!! MAIN OUTPUT VARIABLE(S) : None
!!
!! REFERENCE(S)	:
!! - Hourdin, F. (1992). Study and numerical simulation of the general circulation of 
!! planetary atmospheres, Ph.D. thesis, Paris VII University.
!!
!! FLOWCHART    : None
!! \n
!_ ================================================================================================================================

  SUBROUTINE thermosoil_var_init(kjpindex, zz, zz_coef, dz1, dz2,  &
       shumdiag_perma, stempdiag, &
       snow, pb,snowtemp,snowrho)

  !! 0. Variables and parameter declaration

    !! 0.1 Input variables

    INTEGER(i_std), INTENT(in)                               :: kjpindex          !! Domain size (unitless)
    REAL(r_std), DIMENSION (kjpindex,nbdl), INTENT (in)      :: shumdiag_perma          !! Relative soil humidity on the diagnostic axis 
                                                                                  !! (unitless), [0,1]. (see description of the 
                                                                                  !! variables of thermosoil_main for more 
                                                                                  !! explanations) 
    REAL(r_std), DIMENSION (kjpindex), INTENT (in)     	     :: snow              !! Snow quantity   
    REAL(r_std), DIMENSION (kjpindex), INTENT (in)           :: pb                !! Surface pressure
    REAL(r_std), DIMENSION (kjpindex,nsnow),INTENT(in)       :: snowtemp          !! Snow temperature    
    REAL(r_std), DIMENSION (kjpindex,nsnow),INTENT(in)       :: snowrho           !! Snow density
   
    !! 0.2 Output variables

    REAL(r_std), DIMENSION (ngrnd), INTENT(out)              :: zz                !! depths of the layers'numerical nodes 
                                                                                  !! @tex ($m$)@endtex 
    REAL(r_std), DIMENSION (ngrnd), INTENT(out)              :: zz_coef		  !! depths of the layers'boundaries 
                                                                                  !! @tex ($m$)@endtex 
    REAL(r_std), DIMENSION (ngrnd), INTENT(out)              :: dz1               !! numerical constant depending on the vertical
                                                                                  !! thermal grid only @tex  ($m^{-1}$) @endtex. 
                                                                                  !! (see description
                                                                                  !! of the variables of thermosoil_main for more
                                                                                  !! explanations)
    REAL(r_std), DIMENSION (ngrnd), INTENT(out)              :: dz2               !! thicknesses of the soil thermal layers 
                                                                                  !! @tex ($m$) @endtex
    REAL(r_std), DIMENSION (kjpindex,nbdl), INTENT (out)     :: stempdiag         !! Diagnostic temperature profile @tex ($K$)
                                                                                  !! @endtex

    !! 0.3 Modified variables

    !! 0.4 Local variables

    INTEGER(i_std)                                           :: ier, ji, jg       !! Index (unitless)
    REAL(r_std)                                              :: sum               !! Temporary variable
    REAL(r_std)                                              :: so_capa           !! Average Thermal Conductivity of soils 
                                                                                  !! @tex $(W.m^{-2}.K^{-1})$ @endtex
    REAL(r_std)                                              :: so_cond           !! Average Thermal Conductivity of soils 
                                                                                  !! @tex $(W.m^{-2}.K^{-1})$ @endtex

!_ ================================================================================================================================

  !! 1. Initialization of the parameters of the vertical discretization and of the attenuation depths
    
    !! so_capa and so_cond are temporary variables which contain the average values of soil conductivity 
    !! and soil conductivity and are only needed in thermosoil_var_init to set the vertical layering. 
    so_capa = (so_capa_dry + so_capa_wet)/deux
    so_cond = (so_cond_dry + so_cond_wet)/deux

    cstgrnd=SQRT(one_day / pi)
    lskin = SQRT(so_cond / so_capa * one_day / pi)
    fz1 = 0.3_r_std * cstgrnd
    zalph = deux

    !! Calculate so_capa_ice
    so_capa_ice = so_capa_dry + poros*capa_ice*rho_ice
    WRITE(numout,*) 'Calculation of so_capa_ice=', so_capa_ice,' using poros=',poros,' and capa_ice=',capa_ice
    
  !! 2.  Computing the depth of the thermal levels (numerical nodes) and the layers boundaries
   
    !! Computing the depth of the thermal levels (numerical nodes) and 
    !! the layers boundariesusing the so-called
    !! adimentional variable z' = z/lskin*cstgrnd (with z in m)
    
    !! 2.1 adimensional thicknesses of the layers
    DO jg=1,ngrnd

    !!?? code simplification hopefully possible here with up-to-date compilers !
    !!! This needs to be solved soon. Either we allow CPP options in SECHIBA or the VPP
    !!! fixes its compiler 
    !!!#ifdef VPP5000
      dz2(jg) = fz(REAL(jg,r_std)-undemi+undemi) - fz(REAL(jg-1,r_std)-undemi+undemi)
    !!!#else
    !!!      dz2(jg) = fz(REAL(jg,r_std)) - fz(REAL(jg-1,r_std))
    !!!#endif
    ENDDO
    
    !! 2.2 adimentional depth of the numerical nodes and layers' boudaries
    DO jg=1,ngrnd
      zz(jg)      = fz(REAL(jg,r_std) - undemi)
      zz_coef(jg) = fz(REAL(jg,r_std)-undemi+undemi)
    ENDDO

    !! 2.3 Converting to meters
    DO jg=1,ngrnd
      zz(jg)      = zz(jg) /  cstgrnd * lskin
      zz_coef(jg) = zz_coef(jg) / cstgrnd * lskin 
      dz2(jg)     = dz2(jg) /  cstgrnd * lskin
    ENDDO

    !! 2.4 Computing some usefull constants for the numerical scheme
    DO jg=1,ngrnd-1
      dz1(jg)  = un / (zz(jg+1) - zz(jg))
    ENDDO
    lambda = zz(1) * dz1(1)

    !! 2.5 Get the wetness profile on the thermal vertical grid from the diagnostic axis
    CALL thermosoil_humlev(kjpindex, shumdiag_perma, snow)

    !! 2.6 Thermal conductivity at all levels
    IF (ok_freeze_thermix) THEN
       CALL thermosoil_getdiff( kjpindex, snow, ptn )
    ELSE
       ! Calculations of soil thermal properties without effect of freezing
       CALL thermosoil_getdiff_old_thermix_without_snow( kjpindex )
    ENDIF
    
    
  !! 3. Diagnostics : consistency checks on the vertical grid.

    WRITE (numout,*) 'diagnostic des niveaux dans le sol' !!?? to be changed,
    WRITE (numout,*) 'niveaux intermediaires et pleins'
    sum = zero
    DO jg=1,ngrnd
      sum = sum + dz2(jg)
      WRITE (numout,*) zz(jg),sum
    ENDDO

    
  !! 4. Compute a first diagnostic temperature profile
    
    CALL thermosoil_diaglev(kjpindex, stempdiag)

    IF (long_print) WRITE (numout,*) ' thermosoil_var_init done '

  END SUBROUTINE thermosoil_var_init
  

!! ================================================================================================================================
!! SUBROUTINE   : thermosoil_coef
!!
!>\BRIEF        Calculate soil thermal properties, integration coefficients, apparent heat flux,
!! surface heat capacity,  
!!
!! DESCRIPTION	: This routine computes : \n
!!		1. the soil thermal properties. \n 
!!		2. the integration coefficients of the thermal numerical scheme, cgrnd and dgrnd,
!!              which depend on the vertical grid and on soil properties, and are used at the next 
!!              timestep.\n
!!              3. the soil apparent heat flux and surface heat capacity soilflux
!!              and soilcap, used by enerbil to compute the surface temperature at the next
!!              timestep.\n
!!             -  The soil thermal properties depend on water content (shum_ngrnd_perma, shumdiag_perma) and on the presence 
!!              of snow : snow is integrated into the soil for the thermal calculations, ie if there 
!!              is snow on the ground, the first thermal layer(s) consist in snow, depending on the 
!!              snow-depth. If a layer consists out of snow and soil, wheighed soil properties are 
!!              calculated\n
!!             - The coefficients cgrnd and dgrnd are the integration
!!              coefficients for the thermal scheme \n
!!                              T(k+1)=cgrnd(k)+dgrnd(k)*T(k) \n
!!                                      -- EQ1 -- \n
!!              They correspond respectively to $\beta$ and $\alpha$ from F. Hourdin\'s thesis and 
!!              their expression can be found in this document (eq A19 and A20)
!!             - soilcap and soilflux are the apparent surface heat capacity and flux
!!               used in enerbil at the next timestep to solve the surface
!!               balance for Ts (EQ3); they correspond to $C_s$ and $F_s$ in F.
!!               Hourdin\'s PhD thesis and are expressed in eq. A30 and A31. \n
!!                 soilcap*(Ts(t)-Ts(t-1))/dt=soilflux+otherfluxes(Ts(t)) \n
!!                                      -- EQ3 --\n
!!
!! RECENT CHANGE(S) : None
!!
!! MAIN OUTPUT VARIABLE(S): cgrnd, dgrnd, pcapa, pkappa, soilcap, soilflx
!!
!! REFERENCE(S) :
!! - Hourdin, F. (1992). Study and numerical simulation of the general circulation of planetary atmospheres,
!! Ph.D. thesis, Paris VII University. Remark: the part of F. Hourdin's PhD thesis relative to the thermal
!! integration scheme has been scanned and is provided along with the documentation, with name : 
!! Hourdin_1992_PhD_thermal_scheme.pdf
!!
!! FLOWCHART    : None
!! \n
!_ ================================================================================================================================

  SUBROUTINE thermosoil_coef (kjpindex, dtradia, temp_sol_new, snow, &
                              ptn,      soilcap, soilflx,      zz, &
                              dz1,      dz2,     z1,           zdz1,&
                              zdz2,     cgrnd,   dgrnd)

    !! 0. Variables and parameter declaration

    !! 0.1 Input variables

    INTEGER(i_std), INTENT(in)                             :: kjpindex     !! Domain size (unitless)
    REAL(r_std), INTENT (in)                               :: dtradia      !! Time step in seconds @tex ($s$) @endtex
    REAL(r_std), DIMENSION (kjpindex), INTENT (in)         :: temp_sol_new !! soil surface temperature @tex ($K$) @endtex
    REAL(r_std), DIMENSION (kjpindex), INTENT (in)         :: snow         !! snow mass @tex ($Kg$) @endtex
    REAL(r_std), DIMENSION (ngrnd), INTENT(in)             :: zz           !! depths of the soil thermal numerical nodes 
                                                                           !! @tex ($m$) @endtex 
    REAL(r_std), DIMENSION (ngrnd), INTENT(in)             :: dz1          !! numerical constant depending on the vertical 
                                                                           !! thermal grid only @tex ($m^{-1}$) @endtex 
    REAL(r_std), DIMENSION (ngrnd), INTENT(in)             :: dz2          !! thicknesses of the soil thermal layers
                                                                           !! @tex ($m$) @endtex 
    
    !! 0.2 Output variables

    REAL(r_std), DIMENSION (kjpindex), INTENT (out)        :: soilcap      !! surface heat capacity
                                                                           !! @tex ($J m^{-2} K^{-1}$) @endtex
    REAL(r_std), DIMENSION (kjpindex), INTENT (out)        :: soilflx      !! surface heat flux @tex ($W m^{-2}$) @endtex,
                                                                           !! positive towards the 
                                                                           !! soil, writen as Qg (ground heat flux) in the history 
                                                                           !! files.
    REAL(r_std), DIMENSION (kjpindex), INTENT (out)        :: z1           !! numerical constant @tex ($W m^{-1} K^{-1}$) @endtex

    REAL(r_std), DIMENSION (kjpindex,ngrnd-1), INTENT(out) :: cgrnd        !! matrix coefficient for the computation of soil 
                                                                           !! temperatures (beta in F. Hourdin thesis)
    REAL(r_std), DIMENSION (kjpindex,ngrnd-1), INTENT(out) :: dgrnd        !! matrix coefficient for the computation of soil 
                                                                           !! temperatures (alpha in F. Hourdin thesis)
    REAL(r_std), DIMENSION (kjpindex,ngrnd-1), INTENT(out) :: zdz1         !! numerical (buffer) constant 
                                                                           !! @tex ($W m^{-1} K^{-1}$) @endtex

    REAL(r_std), DIMENSION (kjpindex,ngrnd), INTENT(out)   :: zdz2         !! numerical (buffer) constant  
                                                                           !! @tex ($W m^{-1} K^{-1}$) @endtex

    !! 0.3 Modified variable

    REAL(r_std), DIMENSION (kjpindex,ngrnd), INTENT (inout):: ptn          !! vertically discretized soil temperatures
                                                                           !! @tex ($K$) @endtex

    !! 0.4 Local variables

    INTEGER(i_std)                                         :: ji, jg
    REAL(r_std), DIMENSION(kjpindex)                       :: snow_h       !! snow_h is the snow height @tex ($m$) @endtex 
    REAL(r_std), DIMENSION(kjpindex)                       :: zx1, zx2     !! zx1 and zx2 are the layer fraction consisting in snow
                                                                           !! and soil respectively.
!_ ================================================================================================================================

  !! 1. Computation of the soil thermal properties
   
    ! Computation of the soil thermal properties; snow properties are also accounted for
    IF (ok_freeze_thermix) THEN
       CALL thermosoil_getdiff( kjpindex, snow, ptn )
    ELSE IF (ok_explicitsnow) THEN
       ! Special case with explicit snow model without soil freezing
       CALL thermosoil_getdiff_old_thermix_without_snow( kjpindex )
    ELSE
       ! Special case with old snow without soil freezing
       CALL thermosoil_getdiff_old_thermix_with_snow( kjpindex, snow )
    ENDIF

    ! Energy conservation : Correction to make sure that the same latent heat is released and 
    ! consumed during freezing and thawing
    IF (ok_Ecorr) THEN
       CALL thermosoil_readjust(kjpindex, ptn)
    ENDIF
    

    !! 2. computation of the coefficients of the numerical integration scheme

    ! cgrnd, dgrnd

    !! 2.1.  some "buffer" values
    DO jg=1,ngrnd
      DO ji=1,kjpindex
        zdz2(ji,jg)=pcapa(ji,jg) * dz2(jg)/dtradia
      ENDDO
    ENDDO
    
    DO jg=1,ngrnd-1
      DO ji=1,kjpindex
        zdz1(ji,jg) = dz1(jg) * pkappa(ji,jg)
      ENDDO
    ENDDO
    
    !! 2.2.  the coefficients ! 
    DO ji = 1,kjpindex
      z1(ji) = zdz2(ji,ngrnd) + zdz1(ji,ngrnd-1)
      cgrnd(ji,ngrnd-1) = zdz2(ji,ngrnd) * ptn(ji,ngrnd) / z1(ji)
      dgrnd(ji,ngrnd-1) = zdz1(ji,ngrnd-1) / z1(ji)
    ENDDO

    DO jg = ngrnd-1,2,-1
      DO ji = 1,kjpindex
        z1(ji) = un / (zdz2(ji,jg) + zdz1(ji,jg-1) + zdz1(ji,jg) * (un - dgrnd(ji,jg)))
        cgrnd(ji,jg-1) = (ptn(ji,jg) * zdz2(ji,jg) + zdz1(ji,jg) * cgrnd(ji,jg)) * z1(ji)
        dgrnd(ji,jg-1) = zdz1(ji,jg-1) * z1(ji)
      ENDDO
    ENDDO

  !! 3. Computation of the apparent ground heat flux 
    
    !! Computation of the apparent ground heat flux (> towards the soil) and
    !! apparent surface heat capacity, used at the next timestep by enerbil to
    !! compute the surface temperature.
    DO ji = 1,kjpindex
      soilflx(ji) = zdz1(ji,1) * (cgrnd(ji,1) + (dgrnd(ji,1)-1.) * ptn(ji,1))
      soilcap(ji) = (zdz2(ji,1) * dtradia + dtradia * (un - dgrnd(ji,1)) * zdz1(ji,1))
      z1(ji) = lambda * (un - dgrnd(ji,1)) + un
      soilcap(ji) = soilcap(ji) / z1(ji)
      soilflx(ji) = soilflx(ji) + &
         & soilcap(ji) * (ptn(ji,1) * z1(ji) - lambda * cgrnd(ji,1) - temp_sol_new(ji)) / dtradia 
    ENDDO

    IF (long_print) WRITE (numout,*) ' thermosoil_coef done '

  END SUBROUTINE thermosoil_coef
 
 
!! ================================================================================================================================
!! SUBROUTINE   : thermosoil_profile
!!
!>\BRIEF        In this routine solves the numerical soil thermal scheme, ie calculates the new soil temperature profile; 
!! This profile is then exported onto the diagnostic axis (call thermosoil_diaglev)
!!
!! DESCRIPTION	: The calculation of the new soil temperature profile is based on
!! the cgrnd and dgrnd values from the previous timestep and the surface temperature Ts aka temp_sol_new. (see detailed
!! explanation in the header of the thermosoil module or in the reference).\n
!!                              T(k+1)=cgrnd(k)+dgrnd(k)*T(k)\n
!!                                      -- EQ1 --\n
!!                           Ts=(1-lambda)*T(1) -lambda*T(2)\n 
!!                                      -- EQ2--\n
!!
!! RECENT CHANGE(S) : None
!! 
!! MAIN OUTPUT VARIABLE(S): ptn (soil temperature profile on the thermal axis), 
!!                          stempdiag (soil temperature profile on the diagnostic axis)
!!
!! REFERENCE(S) :
!! - Hourdin, F. (1992). Study and numerical simulation of the general circulation of planetary atmospheres,
!! Ph.D. thesis, Paris VII University. Remark: the part of F. Hourdin's PhD thesis relative to the thermal
!! integration scheme has been scanned and is provided along with the documentation, with name : 
!! Hourdin_1992_PhD_thermal_scheme.pdf
!!
!! FLOWCHART    : None 
!! \n 
!_ ================================================================================================================================

 SUBROUTINE thermosoil_profile (kjpindex, temp_sol_new, ptn, stempdiag, &
                                pkappa_snow,snowdz,snowtemp,grndflux,dtradia)

  !! 0. Variables and parameter declaration

    !! 0.1 Input variables

    INTEGER(i_std), INTENT(in)                               :: kjpindex       !! Domain size (unitless)
    REAL(r_std),DIMENSION (kjpindex), INTENT (in)            :: temp_sol_new   !! Surface temperature at the present time-step 
                                                                               !! @tex ($K$) @endtex
    REAL(r_std),DIMENSION (kjpindex,nsnow),INTENT(in)        :: snowdz         !! Snow depth
    REAL(r_std),DIMENSION (kjpindex,nsnow),INTENT(in)        :: snowtemp       !! Snow temperature
    REAL(r_std),DIMENSION (kjpindex,nsnow),INTENT(in)        :: pkappa_snow    !! Snow thermal conductivity
    REAL(r_std),DIMENSION (kjpindex),INTENT(in)              :: grndflux       !! Net flux into the soil
    REAL(r_std),INTENT(in)                                   :: dtradia        !! Time step (s)
   
    !! 0.2 Output variables
    REAL(r_std),DIMENSION (kjpindex,nbdl), INTENT (out)      :: stempdiag      !! diagnostic temperature profile 
                                                                               !! @tex ($K$) @endtex

    !! 0.3 Modified variables

    REAL(r_std),DIMENSION (kjpindex,ngrnd), INTENT (inout)   :: ptn            !! vertically discretized soil temperatures 
                                                                               !! @tex ($K$) @endtex

    !! 0.4 Local variables

    INTEGER(i_std)                                           :: ji, jg
     
!_ ================================================================================================================================
    
  !! 1. Computes the soil temperatures ptn.

    !! 1.1. ptn(jg=1) using EQ1 and EQ2
    DO ji = 1,kjpindex

       IF (ok_explicitsnow .AND. SUM(snowdz(ji,:)) .GT. 0.0) THEN
          ! Soil temperature calculation with explicit snow if there is snow on the ground
          ptn(ji,1) = (lambda * cgrnd(ji,1) + snowtemp(ji,nsnow)) / (lambda * (un - dgrnd(ji,1)) + un) +&
               grndflux(ji)*dtradia/(pcapa(ji,1)*zz_coef(1))
       ELSE
          ! Standard soil temperature calculation
          ptn(ji,1) = (lambda * cgrnd(ji,1) + temp_sol_new(ji)) / (lambda *(un - dgrnd(ji,1)) + un)
       ENDIF
    ENDDO

    !! 1.2. ptn(jg=2:ngrnd) using EQ1.
    DO jg = 1,ngrnd-1
      DO ji = 1,kjpindex
        ptn(ji,jg+1) = cgrnd(ji,jg) + dgrnd(ji,jg) * ptn(ji,jg)
      ENDDO
    ENDDO

  !! 2. Put the soil temperatures onto the diagnostic axis 
  
    !! Put the soil temperatures onto the diagnostic axis for convenient
    !! use in other routines (stomate..)
    CALL thermosoil_diaglev(kjpindex, stempdiag)

    IF (long_print) WRITE (numout,*) ' thermosoil_profile done '

  END SUBROUTINE thermosoil_profile


!! ================================================================================================================================
!! SUBROUTINE   : thermosoil_diaglev
!!
!>\BRIEF        Interpolation of the soil in-depth temperatures onto the diagnostic profile.
!!
!! DESCRIPTION  : This is a very easy linear interpolation, with intfact(jd, jg) the fraction
!! the thermal layer jg comprised within the diagnostic layer jd. The depths of
!! the diagnostic levels are diaglev(1:nbdl), computed in slowproc.f90.
!!
!! RECENT CHANGE(S) : None
!!
!! MAIN OUTPUT VARIABLE(S): stempdiag (soil temperature profile on the diagnostic axis)
!!
!! REFERENCE(S) : None
!!
!! FLOWCHART    : None 
!! \n 
!_ ================================================================================================================================

  SUBROUTINE thermosoil_diaglev(kjpindex, stempdiag)
    
  !! 0. Variables and parameter declaration

    !! 0.1 Input variables
 
    INTEGER(i_std), INTENT(in)                          :: kjpindex       !! Domain size (unitless)
   
    !! 0.2 Output variables

    REAL(r_std),DIMENSION (kjpindex,nbdl), INTENT (out) :: stempdiag      !! Diagnostoc soil temperature profile @tex ($K$) @endtex
    
    !! 0.3 Modified variables

    !! 0.4 Local variables

    INTEGER(i_std)                                      :: ji, jd, jg
    REAL(r_std)                                         :: lev_diag, prev_diag, lev_prog, prev_prog
    REAL(r_std), SAVE, ALLOCATABLE, DIMENSION(:,:)      :: intfact
!$OMP THREADPRIVATE(intfact)
    LOGICAL, PARAMETER                                  :: check=.FALSE.
!_ ================================================================================================================================
    
  !! 1. Computes intfact(jd, jg)

    !! Computes intfact(jd, jg), the fraction
    !! the thermal layer jg comprised within the diagnostic layer jd.
    IF ( .NOT. ALLOCATED(intfact)) THEN
        
        ALLOCATE(intfact(nbdl, ngrnd))
        
        prev_diag = zero
        DO jd = 1, nbdl
          lev_diag = diaglev(jd)
          prev_prog = zero
          DO jg = 1, ngrnd
             IF ( jg == ngrnd .AND. (prev_prog + dz2(jg)) < lev_diag ) THEN
                lev_prog = lev_diag
             ELSE
                lev_prog = prev_prog + dz2(jg)
             ENDIF
            intfact(jd,jg) = MAX(MIN(lev_diag,lev_prog)-MAX(prev_diag, prev_prog), zero)/(lev_diag-prev_diag)
            prev_prog = lev_prog
          ENDDO
           prev_diag = lev_diag
        ENDDO
        
        IF ( check ) THEN
           WRITE(numout,*) 'thermosoil_diagev -- thermosoil_diaglev -- thermosoil_diaglev --' 
           DO jd = 1, nbdl
              WRITE(numout,*) jd, '-', intfact(jd,1:ngrnd)
           ENDDO
           WRITE(numout,*) "SUM -- SUM -- SUM SUM -- SUM -- SUM"
           DO jd = 1, nbdl
              WRITE(numout,*) jd, '-', SUM(intfact(jd,1:ngrnd))
           ENDDO
           WRITE(numout,*) 'thermosoil_diaglev -- thermosoil_diaglev -- thermosoil_diaglev --' 
        ENDIF
        
    ENDIF

 !! 2. does the interpolation

    stempdiag(:,:) = zero
    DO jg = 1, ngrnd
      DO jd = 1, nbdl
        DO ji = 1, kjpindex
          stempdiag(ji,jd) = stempdiag(ji,jd) + ptn(ji,jg)*intfact(jd,jg)
        ENDDO
      ENDDO
    ENDDO

  END SUBROUTINE thermosoil_diaglev
  

!! ================================================================================================================================
!! SUBROUTINE   : thermosoil_humlev
!!
!>\BRIEF        Interpolates the diagnostic soil humidity profile shumdiag_perma(nbdl, diagnostic axis) onto 
!!              the thermal axis, which gives shum_ngrnd_perma(ngrnd, thermal axis).
!!
!! DESCRIPTION  : Same as in thermosoil_diaglev : This is a very easy linear interpolation, with intfactw(jd, jg) the fraction
!! the thermal layer jd comprised within the diagnostic layer jg. 
!! 
!! The depths of the diagnostic levels are diaglev(1:nbdl), computed in slowproc.f90.
!!
!! RECENT CHANGE(S) : None
!!
!! MAIN OUTPUT VARIABLE(S): shum_ngrnd_perma (soil saturation degree on the thermal axis)
!!
!! REFERENCE(S) : None
!!
!! FLOWCHART    : None 
!! \n 
!_ ================================================================================================================================
  SUBROUTINE thermosoil_humlev(kjpindex, shumdiag_perma, snow)
  
  !! 0. Variables and parameter declaration

    !! 0.1 Input variables
 
    INTEGER(i_std), INTENT(in)                            :: kjpindex    !! Domain size (unitless)
    REAL(r_std),DIMENSION (kjpindex,nbdl), INTENT (in)    :: shumdiag_perma  
    REAL(r_std),DIMENSION (kjpindex), INTENT (in)         :: snow 
    
    !! 0.2 Output variables

    !! 0.3 Modified variables

    !! 0.4 Local variables
    INTEGER(i_std)                                       :: ji, jd, jg
    REAL(r_std)                                          :: lev_diag, prev_diag, lev_prog, prev_prog
    REAL(r_std), DIMENSION(ngrnd,nbdl)                   :: intfactw     !! fraction of each diagnostic layer (jd) comprized within
                                                                         !! a given thermal layer (jg)(0-1, unitless) 
    REAL(r_std), DIMENSION(kjpindex)               :: snow_h
    LOGICAL, PARAMETER :: check=.FALSE.

!_ ================================================================================================================================
    
  !! 1. computes intfactw(jd,jg), the fraction of each diagnostic layer (jg) comprized within a given thermal layer (jd)
    IF ( check ) &
         WRITE(numout,*) 'thermosoil_humlev --' 

    ! Snow height
    snow_h(:)=snow(:)/sn_dens
    !
    shum_ngrnd_perma(:,:) = zero
    DO ji=1,kjpindex
       prev_diag = zero
       DO jd = 1, ngrnd
          lev_diag = prev_diag + dz2(jd)
          prev_prog = snow_h(ji)
          DO jg = 1, nbdl
             IF ( jg == nbdl .AND. diaglev(jg)+snow_h(ji) < lev_diag ) THEN
                lev_prog = lev_diag+snow_h(ji)
             ELSE
                lev_prog = diaglev(jg)+snow_h(ji)
             ENDIF
             intfactw(jd,jg) = MAX(MIN(lev_diag,lev_prog)-MAX(prev_diag, prev_prog), zero)/(lev_diag-prev_diag)
             prev_prog = lev_prog
          ENDDO
          prev_diag = lev_diag
       ENDDO

       DO jg = 1, nbdl
          DO jd = 1, ngrnd
             shum_ngrnd_perma(ji,jd) = shum_ngrnd_perma(ji,jd) + shumdiag_perma(ji,jg)*intfactw(jd,jg)
          ENDDO
       ENDDO
       !
       IF ( check ) THEN
          DO jd = 1, ngrnd
             WRITE(numout,*) ji,jd, '-', intfactw(jd,1:nbdl),'-sum-', SUM(intfactw(jd,1:nbdl))
          ENDDO
       ENDIF
    ENDDO
    IF ( check ) &
         WRITE(numout,*) 'thermosoil_humlev --' 

  END SUBROUTINE thermosoil_humlev


!! ================================================================================================================================
!! SUBROUTINE   : thermosoil_energy
!!
!>\BRIEF         Energy check-up.
!!
!! DESCRIPTION  : I didn\'t comment this routine since at do not understand its use, please
!! ask initial designers (Jan ? Nathalie ?).
!!
!! RECENT CHANGE(S) : None
!!
!! MAIN OUTPUT VARIABLE(S) : ??
!!
!! REFERENCE(S) : None
!!
!! FLOWCHART    : None 
!! \n 
!_ ================================================================================================================================

  SUBROUTINE thermosoil_energy(kjpindex, temp_sol_new, soilcap, first_call)
  
   !! 0. Variables and parameter declaration

    !! 0.1 Input variables

    INTEGER(i_std), INTENT(in)                     :: kjpindex     !! Domain size (unitless)
    LOGICAL, INTENT (in)                           :: first_call   !! First call (true/false)
    REAL(r_std),DIMENSION (kjpindex), INTENT (in)  :: temp_sol_new !! Surface temperature at the present time-step, Ts 
                                                                   !! @tex ($K$) @endtex
    REAL(r_std),DIMENSION (kjpindex), INTENT (in)  :: soilcap      !! Apparent surface heat capacity 
                                                                   !! @tex ($J m^{-2} K^{-1}$) @endtex, 
                                                                   !! see eq. A29 of F. Hourdin\'s PhD thesis.
    
    !! 0.2 Output variables

    !! 0.3 Modified variables
    
    !! 0.4 Local variables
    
    INTEGER(i_std)                                 :: ji, jg
!_ ================================================================================================================================
   
    IF (first_call) THEN

     DO ji = 1, kjpindex
      surfheat_incr(ji) = zero
      coldcont_incr(ji) = zero
      temp_sol_beg(ji)  = temp_sol_new(ji)
      
      DO jg = 1, ngrnd
       ptn_beg(ji,jg)   = ptn(ji,jg)
      ENDDO
      
     ENDDO
    
     RETURN

    ENDIF

     DO ji = 1, kjpindex
      surfheat_incr(ji) = zero
      coldcont_incr(ji) = zero
     ENDDO
    
    !  Sum up the energy content of all layers in the soil.
    DO ji = 1, kjpindex
   
       IF (pcapa_en(ji,1) .LE. sn_capa) THEN
          
          ! Verify the energy conservation in the surface layer
          coldcont_incr(ji) = soilcap(ji) * (temp_sol_new(ji) - temp_sol_beg(ji))
          surfheat_incr(ji) = zero
       ELSE
          
          ! Verify the energy conservation in the surface layer
          surfheat_incr(ji) = soilcap(ji) * (temp_sol_new(ji) - temp_sol_beg(ji))
          coldcont_incr(ji) = zero
       ENDIF
    ENDDO
    
    ptn_beg(:,:)      = ptn(:,:)
    temp_sol_beg(:)   = temp_sol_new(:)

  END SUBROUTINE thermosoil_energy



!! ================================================================================================================================
!! SUBROUTINE   : thermosoil_readjust
!!
!>\BRIEF        
!!
!! DESCRIPTION	: Energy conservation : Correction to make sure that the same latent heat is released and 
!!                consumed during freezing and thawing  
!!
!! RECENT CHANGE(S) : None
!! 
!! MAIN OUTPUT VARIABLE(S): ptn (soil temperature profile on the thermal axis), 
!!                          
!! REFERENCE(S) :
!!
!! FLOWCHART    : None 
!! \n 
!_ ================================================================================================================================

  SUBROUTINE thermosoil_readjust(kjpindex, ptn)

   !! 0. Variables and parameter declaration

    !! 0.1 Input variables
    INTEGER(i_std), INTENT(in)                             :: kjpindex

    !! 0.2 Modified variables
    REAL(r_std),DIMENSION(kjpindex,ngrnd),INTENT(inout)    :: ptn

    !! 0.3 Local variables
    INTEGER(i_std)  :: ji, jg
    REAL(r_std) :: ptn_tmp

    DO jg=1, ngrnd
       DO ji=1, kjpindex
          ! All soil latent energy is put into e_soil_lat(ji)
          ! because the variable soil layers make it difficult to keep track of all
          ! layers in this version
          ! NOTE : pcapa has unit J/K/m3 and pcappa_supp has J/K
          e_soil_lat(ji)=e_soil_lat(ji)+pcappa_supp(ji,jg)*(ptn(ji,jg)-ptn_beg(ji,jg))
       END DO
   END DO

   DO ji=1, kjpindex
      IF (e_soil_lat(ji).GT.min_sechiba.AND.MINVAL(ptn(ji,:)).GT.ZeroCelsius+fr_dT/2.) THEN
         ! The soil is thawed: we spread the excess of energy over the uppermost 6 levels e.g. 2.7m
         ! Here we increase the temperatures
         DO jg=1,6
            ptn_tmp=ptn(ji,jg)
            
            ptn(ji,jg)=ptn(ji,jg)+MIN(e_soil_lat(ji)/pcapa(ji,jg)/zz_coef(6), 0.5)
            e_soil_lat(ji)=e_soil_lat(ji)-(ptn(ji,jg)-ptn_tmp)*pcapa(ji,jg)*dz2(jg)
         ENDDO
      ELSE IF (e_soil_lat(ji).LT.-min_sechiba.AND.MINVAL(ptn(ji,:)).GT.ZeroCelsius+fr_dT/2.) THEN
         ! The soil is thawed
         ! Here we decrease the temperatures
         DO jg=1,6
            ptn_tmp=ptn(ji,jg)
            ptn(ji,jg)=MAX(ZeroCelsius+fr_dT/2., ptn_tmp+e_soil_lat(ji)/pcapa(ji,jg)/zz_coef(6))
            e_soil_lat(ji)=e_soil_lat(ji)+(ptn_tmp-ptn(ji,jg))*pcapa(ji,jg)*dz2(jg)
         END DO
      END IF
   END DO

  END SUBROUTINE thermosoil_readjust
   
!-------------------------------------------------------------------



!! ================================================================================================================================
!! SUBROUTINE   : thermosoil_getdiff
!!
!>\BRIEF          Computes soil heat capacity and conductivity    
!!
!! DESCRIPTION	: Computation of the soil thermal properties; snow properties are also accounted for
!!
!! RECENT CHANGE(S) : None
!! 
!! MAIN OUTPUT VARIABLE(S): ptn (soil temperature profile on the thermal axis), 
!!                          
!! REFERENCE(S) :
!!
!! FLOWCHART    : None 
!! \n 
!_ ================================================================================================================================

  SUBROUTINE thermosoil_getdiff( kjpindex, snow, ptn )

   !! 0. Variables and parameter declaration

    !! 0.1 Input variables
    INTEGER(i_std),INTENT(in)				:: kjpindex
    REAL(r_std),DIMENSION(kjpindex),INTENT (in)	        :: snow       !! Snow mass

    !! 0.2 Modified variables
    REAL(r_std),DIMENSION(kjpindex,ngrnd),INTENT(inout)	:: ptn        !! Soil temperature profile

    !! 0.3 Local variables
    REAL						:: xx         !! Unfrozen fraction of the soil
    REAL(r_std), DIMENSION(kjpindex)             	:: snow_h
    REAL(r_std), DIMENSION(kjpindex,ngrnd) 		:: zx1, zx2    
    REAL			   			:: cap_iw     !! Heat capacity of ice/water mixture 
    REAL						:: csat       !! Thermal conductivity for saturated soil
    INTEGER						:: ji,jg


    DO ji = 1,kjpindex
       IF (.NOT. ok_explicitsnow) THEN      
          ! 1. Determine the fractions of snow and soil
          snow_h(ji) = snow(ji) / sn_dens
      
          !
          !  1.1. The first level
          !
          IF ( snow_h(ji) .GT. zz_coef(1) ) THEN
             ! the 1st level is in the snow => the 1st layer is entirely snow
             zx1(ji,1) = 1.
             zx2(ji,1) = 0.
          ELSE IF ( snow_h(ji) .GT. zero ) THEN      
             ! the 1st level is beyond the snow and the snow is present
             zx1(ji,1) = snow_h(ji) / zz_coef(1)
             zx2(ji,1) = ( zz_coef(1) - snow_h(ji)) / zz_coef(1)	
          ELSE
             ! there is no snow at all, quoi ;-)
             zx1(ji,1) = 0.
             zx2(ji,1) = 1.       
          ENDIF
      
          !
          !  1.2. The other levels
          !
          DO jg = 2, ngrnd
             IF ( snow_h(ji) .GT. zz_coef(jg) ) THEN
                ! the current level is in the snow => the current layer is entirely snow
                zx1(ji,jg) = 1.
                zx2(ji,jg) = 0.
             ELSE IF ( snow_h(ji) .GT. zz_coef(jg-1) ) THEN
                ! the current layer is partially snow
                zx1(ji,jg) = (snow_h(ji) - zz_coef(jg-1)) / (zz_coef(jg) - zz_coef(jg-1))
                zx2(ji,jg) = ( zz_coef(jg) - snow_h(ji)) / (zz_coef(jg) - zz_coef(jg-1))
             ELSE
                ! both levels are out of snow => the current layer is entirely soil	  
                zx1(ji,jg) = 0.
                zx2(ji,jg) = 1.       
             ENDIF
          ENDDO
       ELSE
          zx1(ji,:) = 0.
          zx2(ji,:) = 1.
       END IF

      DO jg = 1, ngrnd
         !
         ! 2. Calculate heat capacity with allowance for permafrost
         ! 2.1. soil heat capacity depending on temperature and humidity
	 
         IF (ptn(ji,jg) .LT. ZeroCelsius-fr_dT/2.) THEN
	    ! frozen soil
            pcapa(ji,jg) = so_capa_dry + shum_ngrnd_perma(ji,jg)*(so_capa_ice - so_capa_dry)!Isa : old version, proved to be correct
	    profil_froz(ji,jg) = 1.
 	    pcappa_supp(ji,jg)= 0.

     	 ELSEIF (ptn(ji,jg) .GT. ZeroCelsius+fr_dT/2.) THEN
	    ! unfrozen soil	 
     	    pcapa(ji,jg) =  so_capa_dry + shum_ngrnd_perma(ji,jg)*(so_capa_wet - so_capa_dry)!Isa : old version, proved to be correct
	    profil_froz(ji,jg) = 0.
 	    pcappa_supp(ji,jg)= 0.
     	 ELSE
     	   ! xx is the unfrozen fraction of soil water	   	   
     	   xx = (ptn(ji,jg)-(ZeroCelsius-fr_dT/2.)) / fr_dT
           profil_froz(ji,jg) = (1. - xx)

	   ! net heat capacity of the ice/water mixture
     	   cap_iw = xx * so_capa_wet + (1.-xx) * so_capa_ice
	   pcapa(ji,jg) = so_capa_dry + shum_ngrnd_perma(ji,jg)*(cap_iw-so_capa_dry) + shum_ngrnd_perma(ji,jg)*poros*lhf*rho_water/fr_dT
 	   pcappa_supp(ji,jg)= shum_ngrnd_perma(ji,jg)*poros*lhf*rho_water/fr_dT*zx2(ji,jg)*dz2(jg)
	   
         ENDIF

         !
	 ! 2.2. Take into account the snow and soil fractions in the layer
	 !
         pcapa(ji,jg) = zx1(ji,jg) * sn_capa + zx2(ji,jg) * pcapa(ji,jg)

	 !
	 ! 2.3. Calculate the heat capacity for energy conservation check 
	 IF ( zx1(ji,jg).GT.0. ) THEN
            pcapa_en(ji,jg) = sn_capa
	 ELSE
            pcapa_en(ji,jg) = pcapa(ji,jg)
	 ENDIF
 
         !
         ! 3. Calculate the heat conductivity with allowance for permafrost (Farouki, 1981, Cold Reg. Sci. Technol.)
         !
	 ! 3.1. unfrozen fraction
         xx = (ptn(ji,jg)-(ZeroCelsius-fr_dT/2.)) / fr_dT * poros
         xx = MIN( poros, MAX( 0., xx ) )

         ! 3.2. saturated conductivity
      	 csat = cond_solid**(1.-poros) * cond_ice**(poros-xx) * cond_water**xx
     	
       	 ! 3.3. unsaturated conductivity
     	 pkappa(ji,jg) =(csat - so_cond_dry)*shum_ngrnd_perma(ji,jg) + so_cond_dry

         !
	 ! 3.4. Take into account the snow and soil fractions in the layer
         pkappa(ji,jg) = un / ( zx1(ji,jg) / sn_cond + zx2(ji,jg) / pkappa(ji,jg) )
      END DO            
    ENDDO   


   
   END SUBROUTINE thermosoil_getdiff

!! ================================================================================================================================
!! SUBROUTINE   : thermosoil_getdiff_old_thermix_with_snow
!!
!>\BRIEF          Computes soil heat capacity and conductivity    
!!
!! DESCRIPTION	: Computes soil heat capacity and conductivity
!!                Special case with old snow without soil freezing
!!
!! RECENT CHANGE(S) : None
!! 
!! MAIN OUTPUT VARIABLE(S):
!!                          
!! REFERENCE(S) :
!!
!! FLOWCHART    : None 
!! \n 
!_ ================================================================================================================================


   SUBROUTINE thermosoil_getdiff_old_thermix_with_snow( kjpindex, snow )


   !! 0. Variables and parameter declaration

    !! 0.1 Input variables
    INTEGER(i_std), INTENT(in) :: kjpindex
    REAL(r_std),DIMENSION(kjpindex),INTENT (in)	        :: snow

    !! 0.2 Local variables
    INTEGER						:: ji,jg
    REAL(r_std), DIMENSION(kjpindex)                    :: snow_h       !! snow_h is the snow height @tex ($m$) @endtex 
    REAL(r_std), DIMENSION(kjpindex)                    :: zx1, zx2     !! zx1 and zx2 are the layer fraction consisting in snow and soil respectively.

     
    ! Computation of the soil thermal properties; snow properties are also accounted for

    DO ji = 1,kjpindex
      snow_h(ji) = snow(ji) / sn_dens

      IF ( snow_h(ji) .GT. zz_coef(1) ) THEN
          pcapa(ji,1) = sn_capa
          pcapa_en(ji,1) = sn_capa
          pkappa(ji,1) = sn_cond
      ELSE IF ( snow_h(ji) .GT. zero ) THEN
          pcapa_en(ji,1) = sn_capa
          zx1(ji) = snow_h(ji) / zz_coef(1)
          zx2(ji) = ( zz_coef(1) - snow_h(ji)) / zz_coef(1)
          pcapa(ji,1) = zx1(ji) * sn_capa + zx2(ji) * so_capa_wet
          pkappa(ji,1) = un / ( zx1(ji) / sn_cond + zx2(ji) / so_cond_wet )
      ELSE
          pcapa(ji,1) = so_capa_dry + shum_ngrnd_perma(ji,1)*(so_capa_wet - so_capa_dry)
          pkappa(ji,1) = so_cond_dry + shum_ngrnd_perma(ji,1)*(so_cond_wet - so_cond_dry)
          pcapa_en(ji,1) = so_capa_dry + shum_ngrnd_perma(ji,1)*(so_capa_wet - so_capa_dry)
      ENDIF
      !
      DO jg = 2, ngrnd - 2
        IF ( snow_h(ji) .GT. zz_coef(jg) ) THEN
            pcapa(ji,jg) = sn_capa
            pkappa(ji,jg) = sn_cond
            pcapa_en(ji,jg) = sn_capa
        ELSE IF ( snow_h(ji) .GT. zz_coef(jg-1) ) THEN
            zx1(ji) = (snow_h(ji) - zz_coef(jg-1)) / (zz_coef(jg) - zz_coef(jg-1))
            zx2(ji) = ( zz_coef(jg) - snow_h(ji)) / (zz_coef(jg) - zz_coef(jg-1))
            pcapa(ji,jg) = zx1(ji) * sn_capa + zx2(ji) * so_capa_wet
            pkappa(ji,jg) = un / ( zx1(ji) / sn_cond + zx2(ji) / so_cond_wet )
            pcapa_en(ji,jg) = sn_capa
        ELSE
            pcapa(ji,jg) = so_capa_dry + shum_ngrnd_perma(ji,jg)*(so_capa_wet - so_capa_dry)
            pkappa(ji,jg) = so_cond_dry + shum_ngrnd_perma(ji,jg)*(so_cond_wet - so_cond_dry)
            pcapa_en(ji,jg) = so_capa_dry + shum_ngrnd_perma(ji,jg)*(so_capa_wet - so_capa_dry)
        ENDIF
      ENDDO
    
    ENDDO ! DO ji = 1,kjpindex
 
    END SUBROUTINE thermosoil_getdiff_old_thermix_with_snow



!! ================================================================================================================================
!! SUBROUTINE   : thermosoil_getdiff_old_thermix_without_snow
!!
!>\BRIEF          Computes soil heat capacity and conductivity    
!!
!! DESCRIPTION	: Calculations of soil thermal properties without effect of freezing and snow
!!                
!!
!! RECENT CHANGE(S) : None
!! 
!! MAIN OUTPUT VARIABLE(S):
!!                          
!! REFERENCE(S) :
!!
!! FLOWCHART    : None 
!! \n 
!_ ================================================================================================================================

    SUBROUTINE thermosoil_getdiff_old_thermix_without_snow( kjpindex )

   !! 0. Variables and parameter declaration

    !! 0.1 Input variables
      INTEGER(i_std), INTENT(in) :: kjpindex

    !! 0.1 Local variables
      INTEGER						  :: ji,jg

     
      DO jg = 1,ngrnd
         DO ji = 1,kjpindex
            pkappa(ji,jg) = so_cond_dry + shum_ngrnd_perma(ji,jg)*(so_cond_wet - so_cond_dry)
            pcapa(ji,jg) = so_capa_dry + shum_ngrnd_perma(ji,jg)*(so_capa_wet - so_capa_dry)
            pcapa_en(ji,jg) = so_capa_dry + shum_ngrnd_perma(ji,jg)*(so_capa_wet - so_capa_dry)
         ENDDO
      ENDDO

    END SUBROUTINE thermosoil_getdiff_old_thermix_without_snow

!! ================================================================================================================================
!! SUBROUTINE   : read_permafrostmap
!!
!>\BRIEF          
!!
!! DESCRIPTION	: Read permafrost map
!!                
!!
!! RECENT CHANGE(S) : None
!! 
!! MAIN OUTPUT VARIABLE(S):
!!                          
!! REFERENCE(S) :
!!
!! FLOWCHART    : None 
!! \n 
!_ ================================================================================================================================

  SUBROUTINE read_permafrostmap(kjpindex,lalo,overburden,excess_ice,permafrost)
    
    !! 0. Variables and parameter declaration

    !! 0.1 Input variables
    INTEGER(i_std), INTENT(in) :: kjpindex
    REAL(r_std), DIMENSION(kjpindex,2), INTENT(in) :: lalo

    !! 0.2 Modified variables
    REAL(r_std), DIMENSION(kjpindex), INTENT(inout) :: overburden
    REAL(r_std), DIMENSION(kjpindex), INTENT(inout) :: excess_ice
    REAL(r_std), DIMENSION(kjpindex), INTENT(inout) :: permafrost
    
    !! 0.3 Local variables
    INTEGER(i_std) :: il, ils, ip, ix, iy, imin, jmin, ier
    REAL(r_std) :: dlon, dlonmin, dlat, dlatmin
    CHARACTER(LEN=80) :: filename
    INTEGER(i_std) :: iml, jml, lml, tml, fid
    REAL(r_std),ALLOCATABLE,DIMENSION(:,:) :: xx,yy, permafrost_file, continuous_file, discontinuous_file
    REAL(r_std),ALLOCATABLE,DIMENSION(:,:) :: sporadic_file, isolated_file, overburden_file, excess_ice_file
    REAL(r_std),ALLOCATABLE,DIMENSION(:) :: x,y
    REAL(r_std) :: lev(1), date, dt
    INTEGER(i_std) :: itau(1)
    REAL(r_std),DIMENSION(kjpindex) :: tref
    

    filename = 'NONE'
    CALL getin('PERMAFROST_MAP_FILE',filename)
    IF ( filename .EQ. "NONE" ) THEN
    ELSE
       CALL flininfo(filename,iml, jml, lml, tml, fid)
       ALLOCATE (yy(iml,jml), stat=ier)
       ALLOCATE (xx(iml,jml), stat=ier)
       ALLOCATE (x(iml),y(jml), stat=ier)
       ALLOCATE (continuous_file(iml,jml), stat=ier)
       ALLOCATE (discontinuous_file(iml,jml), stat=ier)
       ALLOCATE (sporadic_file(iml,jml), stat=ier)
       ALLOCATE (isolated_file(iml,jml), stat=ier)
       ALLOCATE (overburden_file(iml,jml), stat=ier)
       ALLOCATE (excess_ice_file(iml,jml), stat=ier)
       ALLOCATE (permafrost_file(iml,jml), stat=ier)
       CALL flinopen (filename, .FALSE., iml, jml, lml, &
            xx, yy, lev, tml, itau, date, dt, fid)
       CALL flinget (fid, 'continuous_permafrost', iml, jml, lml, tml, &
            1, 1, continuous_file)
       CALL flinget (fid, 'discontinuous_permafrost', iml, jml, lml, tml, &
            1, 1, discontinuous_file)
       CALL flinget (fid, 'sporadic_permafrost', iml, jml, lml, tml, &
            1, 1, sporadic_file)
       CALL flinget (fid, 'isolated_permafrost', iml, jml, lml, tml, &
            1, 1, isolated_file)
       CALL flinget (fid, 'thick_overburden', iml, jml, lml, tml, &
            1, 1, overburden_file)
       CALL flinget (fid, 'high_ground_ice_content', iml, jml, lml, tml, &
            1, 1, excess_ice_file)
       CALL flinclo (fid)
       ! On suppose que le fichier est regulier.
       ! Si ce n'est pas le cas, tant pis. Les temperatures seront mal
       ! initialisees et puis voila. De toute maniere, il faut avoir
       ! l'esprit mal tourne pour avoir l'idee de faire un fichier de
       ! climatologie avec une grille non reguliere.
       permafrost_file(:,:) = continuous_file + discontinuous_file + sporadic_file + isolated_file
       x(:) = xx(:,1)
       y(:) = yy(1,:)
       ! prendre la valeur la plus proche
       DO ip = 1, kjpindex
          dlonmin = HUGE(1.)
          DO ix = 1,iml
             dlon = MIN( ABS(lalo(ip,2)-x(ix)), ABS(lalo(ip,2)+360.-x(ix)), ABS(lalo(ip,2)-360.-x(ix)) )
             IF ( dlon .LT. dlonmin ) THEN
                imin = ix
                dlonmin = dlon
             ENDIF
          ENDDO
          dlatmin = HUGE(1.)
          DO iy = 1,jml
             dlat = ABS(lalo(ip,1)-y(iy))
             IF ( dlat .LT. dlatmin ) THEN
                jmin = iy
                dlatmin = dlat
             ENDIF
          ENDDO
          permafrost(ip) = permafrost_file(imin,jmin)
          overburden(ip) = overburden_file(imin,jmin)
          excess_ice(ip) = excess_ice_file(imin,jmin)
       ENDDO
       DEALLOCATE (yy)
       DEALLOCATE (xx)
       DEALLOCATE (x)
       DEALLOCATE (continuous_file)
       DEALLOCATE (discontinuous_file)
       DEALLOCATE (sporadic_file)
       DEALLOCATE (isolated_file)
       DEALLOCATE (overburden_file)
       DEALLOCATE (excess_ice_file)
       DEALLOCATE (permafrost_file)
    ENDIF
    WRITE(numout,*) 'cdk: #points permafrost', SUM(permafrost)
    WRITE(numout,*) 'cdk: #points overburden', SUM(overburden)
    WRITE(numout,*) 'cdk: #points excess_ice', SUM(excess_ice)
    
  END SUBROUTINE read_permafrostmap


!! ================================================================================================================================
!! SUBROUTINE   : read_reftempfile
!!
!>\BRIEF          
!!
!! DESCRIPTION	: Read file with longterm temperature
!!                
!!
!! RECENT CHANGE(S) : None
!! 
!! MAIN OUTPUT VARIABLE(S): reftemp : Reference temerature
!!                          
!! REFERENCE(S) :
!!
!! FLOWCHART    : None 
!! \n 
!_ ================================================================================================================================

 SUBROUTINE read_reftempfile(kjpindex,lalo,reftemp)
    

    !! 0. Variables and parameter declaration

    !! 0.1 Input variables
    INTEGER(i_std), INTENT(in) :: kjpindex
    REAL(r_std), DIMENSION(kjpindex,2), INTENT(in) :: lalo

    !! 0.2 Modified variables
    REAL(r_std), DIMENSION(kjpindex, ngrnd), INTENT(inout) :: reftemp

    !! 0.3 Local variables
    INTEGER(i_std) :: il, ils, ip, ix, iy, imin, jmin, ier
    REAL(r_std) :: dlon, dlonmin, dlat, dlatmin
    CHARACTER(LEN=80) :: filename
    INTEGER(i_std) :: iml, jml, lml, tml, fid
    REAL(r_std),ALLOCATABLE,DIMENSION(:,:) :: xx,yy
    REAL(r_std),ALLOCATABLE,DIMENSION(:,:) :: reftemp_file
    REAL(r_std),ALLOCATABLE,DIMENSION(:) :: x,y
    REAL(r_std) :: lev(1), date, dt
    INTEGER(i_std) :: itau(1)
    REAL(r_std),DIMENSION(kjpindex) :: tref
    
    ! plus bas, on prend la temperature lue dans un fichier climato si celui-ci existe
    filename = 'reftemp.nc'
    CALL getin('REFTEMP_FILE',filename)

       CALL flininfo(filename,iml, jml, lml, tml, fid)
       ALLOCATE (yy(iml,jml), stat=ier)
       ALLOCATE (xx(iml,jml), stat=ier)
       ALLOCATE (x(iml),y(jml), stat=ier)
       ALLOCATE (reftemp_file(iml,jml), stat=ier)

       CALL flinopen (filename, .FALSE., iml, jml, lml, &
            xx, yy, lev, tml, itau, date, dt, fid)
       CALL flinget (fid, 'temperature', iml, jml, lml, tml, &
            1, 1, reftemp_file)
       CALL flinclo (fid)
       ! On suppose que le fichier est regulier.
       ! Si ce n'est pas le cas, tant pis. Les temperatures seront mal
       ! initialisees et puis voila. De toute maniere, il faut avoir
       ! l'esprit mal tourne pour avoir l'idee de faire un fichier de
       ! climatologie avec une grille non reguliere.
       x(:) = xx(:,1)
       y(:) = yy(1,:)
       ! prendre la valeur la plus proche
       DO ip = 1, kjpindex
          dlonmin = HUGE(1.)
          DO ix = 1,iml
             dlon = MIN( ABS(lalo(ip,2)-x(ix)), ABS(lalo(ip,2)+360.-x(ix)), ABS(lalo(ip,2)-360.-x(ix)) )
             IF ( dlon .LT. dlonmin ) THEN
                imin = ix
                dlonmin = dlon
             ENDIF
          ENDDO
          dlatmin = HUGE(1.)
          DO iy = 1,jml
             dlat = ABS(lalo(ip,1)-y(iy))
             IF ( dlat .LT. dlatmin ) THEN
                jmin = iy
                dlatmin = dlat
             ENDIF
          ENDDO
          reftemp(ip, :) = reftemp_file(imin,jmin)+273.15
       ENDDO
       DEALLOCATE (yy)
       DEALLOCATE (xx)
       DEALLOCATE (x)
       DEALLOCATE (reftemp_file)


    
  END SUBROUTINE read_reftempfile


END MODULE thermosoil
